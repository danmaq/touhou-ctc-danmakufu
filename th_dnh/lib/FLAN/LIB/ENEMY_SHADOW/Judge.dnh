//////////////////////////////////////////////////////////////////////
//====================================================================
//
//	Framework of LunAtic Notation
//	(c)2006 danmaq
//
//		※各上位ライブラリから間接的にインクルードされます。
//			直接インクルードすることはありません。
//
//====================================================================
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//	定数(書換不可)
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//	定数(書換可能)
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//	メンバ変数(書換不可)
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	判定関連
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

/**
*	当たり判定を登録します。
*	SetCollisionA/SetCollisionBのラッパーです。
*
*	@param nX 当たり判定の中心X座標
*	@param nY 当たり判定の中心Y座標
*	@param nCollisionA 敵本体の被弾判定半径(0指定で判定無し)
*	@param nCollisionB 敵本体の体当たり接触判定半径(0指定で判定無し)
*/
function __Collision( let nX, let nY, let nCollisionA, let nCollisionB ){
	if( nCollisionA > 0 ){ SetCollisionA( nX, nY, nCollisionA ); }
	if( nCollisionB > 0 ){ SetCollisionB( nX, nY, nCollisionB ); }
}

/**
*	自分自身の座標を中心に当たり判定を登録します。
*	__Collisionのラッパーです。
*
*	@param nCollisionA 敵本体の被弾判定半径(0指定で判定無し)
*	@param nCollisionB 敵本体の体当たり接触判定半径(0指定で判定無し)
*/
function Collision( let nCollisionA, let nCollisionB ){
	if( nCollisionA > 0 ){ SetCollisionA( GetX(), GetY(), nCollisionA ); }
	if( nCollisionB > 0 ){ SetCollisionB( GetX(), GetY(), nCollisionB ); }
}

/**
*	毎フレーム自分自身の座標を確認し、画面から一定以上はみ出ていたら自殺します。
*	注意:自動的に内部から呼ばれますので直接呼び出すことは通常ありません。
*/
task __CheckGoneLoop(){
	loop{
		yield;
		if( !FLAN_ESS_NOGONE && IsOut( FLAN_RINGOUT_BORDER ) ){ VanishEnemy(); }
	}
}
