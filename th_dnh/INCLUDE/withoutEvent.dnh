//////////////////////////////////////////////////////////////////////
//====================================================================
//
//	イベントスクリプト以外の共通下位ライブラリ
//
//		※各上位ライブラリから間接的にインクルードされます。
//			直接インクルードすることはありません。
//		※イベントスクリプトでは使用できません。
//
//====================================================================
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	下位ライブラリをインクルード
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
#include_function ".\INCLUDE\Common.dnh"


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	インデックスをインクルード
//	※夢終劇以外に流用する場合は必要に応じて削除してください
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
#include_function ".\IMAGE\index.dnh"
#include_function ".\SOUND\index.dnh"


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	メンバ変数
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	※@MainLoop()の最後にm_nCount++と記述してください
let m_nPhase = [ -1 ];	//	フェーズ(最初の要素ほど上のスタック)
let m_nPrevPhase = -1;	//	前のフェーズ
let m_nCount = 0;		//	カウンタ
let m_nPhaseCount = 0;		//	カウンタ


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	フェーズ関連
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	現在のスタック段数を取得する
function GetPhaseStack(){ return length( m_nPhase ); }

//	現在のフェーズを取得する
function GetPhase(){ return m_nPhase[ 0 ]; }

//	指定したフェーズに移動する
function SetPhase( let nPhase ){
	m_nPrevPhase = GetPhase();
	m_nPhase[ 0 ] = nPhase;
	m_nPhaseCount = m_nCount;
}

//	指定した数だけフェーズを先送りする
function AddPhase( let nAdd ){
	m_nPrevPhase = GetPhase();
	m_nPhase[ 0 ] = m_nPhase[ 0 ] + nAdd;
	m_nPhaseCount = m_nCount;
}

//	次のフェーズに移動する
function NextPhase(){ AddPhase( 1 ); }

//	スタックを積んで指定したフェーズに移動する
function GosubPhase( let nPhase ){
	m_nPrevPhase = GetPhase();
	m_nPhase = [ nPhase ] ~ m_nPhase;
	m_nPhaseCount = m_nCount;
}

//	最上段スタックを削除し前のフェーズに戻る
function ReturnPhase(){
	if( GetPhaseStack() > 1 ){
		m_nPrevPhase = GetPhase();
		m_nPhase = erase( m_nPhase, 0 );
	}
	m_nPhaseCount = m_nCount;
}

//	スタックをすべて破棄する
function ClearPhase(){
	let nNowPhase = GetPhase();
	m_nPhase = m_nPhase[ 0..0 ];
	m_nPhase = m_nPhase ~ [ nNowPhase ];
}

//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	マイクロスレッド制御
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	指定フレーム数待機(みだりに少ないフレーム数で呼び出さないこと)
function _Wait( let frame ){ if( frame > 0 ){ loop( frame ){ yield }; } }

//	敵が誰も居なくなるまで待機
function WaitZeroEnemy(){ while( GetEnemyNum() != 0 ){ yield; } }


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	算術関数
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	-expr〜+exprの乱数を返す
function RandBlur( let expr ){ return rand( -expr, expr ); }


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	判定関数
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	画面からdeadline以上はみ出ているか否かを返す
function IsOutPos( let x, let y, let nDeadline ){
	return (
		x < GetClipMinX() - nDeadline ||
		x > GetClipMaxX() + nDeadline ||
		y < GetClipMinY() - nDeadline ||
		y > GetClipMaxY() + nDeadline
	);
}


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	絵画関数
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	テクスチャszTexFileの内容を全て指定位置に絵画する
function _DrawChr( let szTexFile, let x, let y ){
	SetTexture( szTexFile );
	DrawGraphic( x, y );
}

//	テクスチャszTexFileの内容の一部のみを指定位置に絵画する
function _DrawChrRect( let szTexFile, let dstx, let dsty, let srcx1, let srcy1, let srcx2, let srcy2 ){
	SetGraphicRect( srcx1, srcy1, srcx2, srcy2 );
	_DrawChr( szTexFile, dstx, dsty );
}

//	テクスチャszTexFileの内容を全て中央に絵画する
function DrawCenter( let szTexFile ){ _DrawChr( szTexFile, GetCenterX(), GetCenterY() ); }

//	テクスチャszTexFileの内容を全てプレイヤー位置に絵画する
function DrawPlayer( let szTexFile ){ _DrawChr( szTexFile, GetPlayerX(), GetPlayerY() ); }


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	ロード/セーブ関連
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	読み込んだテクスチャ/効果音を複数一気に解放する
function DeleteGraphicList( let aszGraphicFileList, let aszSEFileList ){
	ascent( let i in 0..2 ){
		ascent( let j in 0..[ length( aszGraphicFileList ), length( aszSEFileList ) ][ i ] ){
			alternative( i )
			case( 0 ){ DeleteGraphic( aszGraphicFileList[ j ] ); }
			case( 1 ){ DeleteSE( aszSEFileList[ j ] ); }
		}
	}
}
