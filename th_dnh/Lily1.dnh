#東方弾幕風
#Title[Lily - 通常攻撃1]
#Text[ステージ1C 中ボス
リリー・ホワイト

下記以外のスタート＝Easy
スキップ＋スタート＝Normal
ユーザー＋スタート＝Hard
ｽｷｯﾌﾟ＋ﾕｰｻﾞｰ＋ｽﾀｰﾄ＝Lunatic]
#Image[]
#BackGround[Default]
#Player[FREE]
#ScriptVersion[2]

script_enemy_main{

	// 共通関数読み込み
	#include_function ".\INCLUDE\Enemy.dnh"

	// 画像及び効果音ファイル
	let imgBoss=dotBossLily;

	// 難易度
	Debug_SetLevel;
	let Lv=GetCommonDataDefault("Level",0);

	let warpSt=0;
	let warpFr=0;
	let maxWarpFr=16;

	// -------------------------------------------------------------------------
	@Initialize{

		// 画像及び効果音をロード
		LoadGraphic(imgBoss);

		// スペルカード設定（カード名、スコア、制限時間、弾削除範囲等）
		SetTimer(38);
		SetShotAutoDeleteClip(64,64,64,20);
		SetEnemyMarker(true);

		// ボスステータス設定（ライフ、ダメージ率）
		SetLife(2500);
		SetDamageRate(100,50);
		SetX(cenX);
		SetY(minY+80);

		Main;

	}

	// -------------------------------------------------------------------------
	@MainLoop{

		// 当たり判定（自弾,体当たり）
		if(warpSt!=2){Collision(32,24);}

		// カウンタ加算
		m_nCount++;

		yield;

	}

	// メイン処理 --------------------------------------------------------------
	task Main{

		SetInvincibility(122);
		_Wait(2);

		// 発動
		ExplosionBoss;
		_Wait(60);

		let assign=1;

		loop{

			// ワープ移動
			let area=1;
			if(GetPlayerX>GetX){area=2;}
			warp(maxWarpFr+40,area);
			_Wait(90);

			// 花弾
			FlowerShot(assign);
			assign*=-1;
			_Wait(90);

			// ワープ移動
			warp(maxWarpFr+40,0);
			_Wait(90);

			// 花弾
			FlowerShot(assign);
			assign*=-1;
			_Wait(90);

			// ワープ移動
			area=3-area;
			warp(maxWarpFr+40,area);
			_Wait(90);

			// 花弾
			FlowerShot(assign);
			assign*=-1;
			_Wait(90);

			// ワープ移動
			warp(maxWarpFr+40,3);
			_Wait(120);

			// 対称弾＆移動
			SymmetryShot;
			let power=300;
			let angle=90;
			SetMovePositionHermite(cenX,minY+40,power,angle,power,-angle,120);
			_Wait(180);

		}

	}

	// 花弾 --------------------------------------------------------------------
	task FlowerShot(assign){

		let num=[3,5,9,12];
		let way_=8;
		let way=way_*6;
		let baseSpeed0=0.8;
		let maxSpeed0=2.4+0.6*Lv;
		let numSpeed0=(maxSpeed0-baseSpeed0)/(num[Lv]-1);
		let speed1=1.4+0.2*Lv;
		let baseAngle=rand(0,360);
		let numAngle=10*assign;
		let wayAngle=360/way*assign;
		let graphic=[PURPLE21,AQUA12];
		let delay=15;
		let fr1=90;

		SetShotDirectionType(ABSOLUTE);
		ascent(let i in 0 .. num[Lv]){
			let speed0=baseSpeed0+numSpeed0*i;
			let accSpeed0=-speed0/fr1;
			ascent(let j in 0 .. way){
				let angle=baseAngle+numAngle*i+wayAngle*j;
				CreateShotA(0,GetX,GetY,delay);
				if(j%way_<way_/2){
					SetShotDataA(0,0,speed0,angle,0,accSpeed0,0,graphic[0]);
					SetShotDataA(0,fr1,speed1,angle,0,0,0,graphic[0]);
				}
				else{
					SetShotDataA(0,0,speed0,angle,0,accSpeed0,0,graphic[1]);
					SetShotDataA(0,fr1,speed1*0.75,angle,0,0,0,graphic[1]);
				}
				FireShot(0);
			}
		}

	}

	// 対称弾 ------------------------------------------------------------------
	task SymmetryShot{

		let num=30;
		let way=[1,2,5,9];
		let symX=[-15,15];
		let minSpeed=0.8;
		let maxSpeed=1.6+0.4*Lv;
		let numSpeed=0.02;
		let wideAngle=0;
		let numAngle=(225-wideAngle)/(num-1);
		let wayAngle=0;
		if(Lv>0){wayAngle=wideAngle/(way[Lv]-1);}
		let baseAngle=[0,180];
		let graphic=[RED04,BLUE04];
		let delay=5;
		let assign=[1,-1];
		let fr=4;

		ascent(let i in 0 .. num){
			SetShotDirectionType(ABSOLUTE);
			ascent(let j in 0 .. way[Lv]){
				let speed=rand(minSpeed,maxSpeed)+numSpeed*i;
				ascent(let k in 0 .. 2){
					let angle=baseAngle[k]+(numAngle*i+wayAngle*j)*assign[k];
					CreateShot01(GetX+symX[k],GetY,speed,angle,graphic[k],delay);
				}
			}
			_Wait(fr);
		}

	}

	// ワープ移動 --------------------------------------------------------------
	task warp(let fr, let area){

		// 消滅
		warpSt=1;
		warpFr=0;
		loop(maxWarpFr){
			yield;
			warpFr++;
		}

		// 待ち
		SetEnemyMarker(false);
		warpSt=2;
		SetX(cenX);
		SetY(minY-400);
		_Wait(fr-maxWarpFr*2);

		// 出現
		SetEnemyMarker(true);
		alternative(area)
		case(1){
			SetX(rand(minX+90,cenX-60));
			SetY(minY+100+rand(-20,20));
		}
		case(2){
			SetX(rand(cenX+60,maxX-90));
			SetY(minY+100+rand(-20,20));
		}
		case(3){
			SetX(cenX);
			SetY(cenY-60);
		}
		others{
			SetX(cenX);
			SetY(minY+100);
		}
		warpSt=3;
		warpFr=0;
		loop(maxWarpFr){
			yield;
			warpFr++;
		}
		warpSt=0;

	}

	// -------------------------------------------------------------------------
	@Finalize{

		// ロードしたファイルを削除
		DeleteGraphic(imgBoss);

	}

	// -------------------------------------------------------------------------
	@DrawLoop{

		// ボス描画
		let x=0;
		let y=0;
		let sLength=128;
		SetAlpha(255);
		SetColor(255,255,255);
		setDrawData;
		_DrawChrRectSqr(imgBoss,GetX,GetY,x,y,sLength);

	}

	// 描画倍率 ----------------------------------------------------------------
	function setDrawData{

		alternative(warpSt)
		case(1){
			let scX=1;
			let scY=1;
			let halfWarpFr=maxWarpFr/2;
			if(warpFr<halfWarpFr){
				scX=1+0.5/halfWarpFr*warpFr;
				scY=1-0.9/halfWarpFr*warpFr;
			}
			else{
				scX=1.5-1.5/halfWarpFr*(warpFr-halfWarpFr);
				scY=0.1+2.4/halfWarpFr*(warpFr-halfWarpFr);
			}
			SetGraphicScale(scX,scY);
			SetAlpha(255);
		}
		case(2){
			SetGraphicScale(1,1);
			SetAlpha(0);
		}
		case(3){
			let scX=1;
			let scY=1;
			let halfWarpFr=maxWarpFr/2;
			if(warpFr<halfWarpFr){
				scX=1.5/halfWarpFr*warpFr;
				scY=2.5-2.4/halfWarpFr*warpFr;
			}
			else{
				scX=1.5-0.5/halfWarpFr*(warpFr-halfWarpFr);
				scY=0.1+0.9/halfWarpFr*(warpFr-halfWarpFr);
			}
			SetGraphicScale(scX,scY);
			SetAlpha(255);
		}
		others{
			SetGraphicScale(1,1);
			SetAlpha(255);
		}

	}

}
