//////////////////////////////////////////////////////////////////////
//====================================================================
//
//	プロポーショナルビットマップフォントライブラリ
//
//		※ステージスクリプトライブラリ肥大化防止のため隔離しました。
//			ライブラリから自動的にインクルードされます
//
//====================================================================
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	定数
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

let FONT_SIGN_SJIS = "KANJI";
let FONT_SJIS_GAPPOS	= [		// SJISコードの空白ポイント
	0,		62,		108,	115,	122,	137,	145,	146,	156,	182,	208,	291,	354,	378,	401,	425,	458,	473,	491,	523,	553,	576,	577,	606,	700,
	763,	888,	951,	1076,	1139,	1264,	1327,	1452,	1515,	1640,	1703,	1828,	1891,	2016,	2079,	2204,	2267,	2392,	2455,	2580,	2643,	2768,	2831,	2956,	3019,
	3144,	3207,	3332,	3395,	3520,	3571,	3665,	3728,	3853,	3916,	4041,	4104,	4229,	4292,	4417,	4480,	4605,	4668,	4793,	4856,	4981,	5044,	5169,	5232,	5357,
	5420,	5545,	5608,	5733,	5796,	5921,	5984,	6109,	6172,	6297,	6360,	6485,	6548,	6673,	6736,	6861,	6924,	6961,	6996,	7121,	7184,	7309,	7321
];
let FONT_SJIS_GAPLEN	= [		// SJISコードの空白長
	33088,	1,		11,		8,		11,		7,		4,		82,		7,		7,		4,		78,		1,		8,		8,		105,	15,		1,		13,		641,	1,		8,		1,		258,	67,
	1,		67,		1,		67,		1,		67,		1,		67,		1,		67,		1,		67,		1,		67,		1,		67,		1,		67,		1,		67,		1,		67,		1,		67,		1,
	67,		1,		67,		1,		67,		44,		67,		1,		67,		1,		67,		1,		67,		1,		67,		1,		67,		1,		67,		1,		16451,	1,		67,		1,		67,
	1,		67,		1,		67,		1,		67,		1,		67,		1,		67,		1,		67,		1,		67,		1,		67,		1,		4023,	1,		67,		1,		67,		2
];

let FONT_TEX_WIDTH = 512;
let FONTSMALL_TEX_WIDTH = 256;
//	48ポイント
let FONT48_X = [
	0, 18, 44, 78, 112, 152, 188, 208, 230, 252, 288, 326, 344, 382, 400, 448, 480,
	0, 34, 66, 102, 134, 166, 198, 230, 262, 280, 298, 336, 372, 410, 440,
	0, 42, 78, 114, 152, 186, 222, 260, 298, 314, 344, 380, 416, 454,
	0, 38, 72, 110, 148, 182, 220, 256, 294, 336, 374, 412, 448, 468,
	0, 22, 48, 98, 124, 154, 184, 214, 244, 276, 304, 334, 364, 382, 408, 440, 458,
	0, 30, 60, 90, 120, 148, 176, 204, 236, 268, 306, 340, 370, 402, 424, 440, 460,
	0
];
let FONT48_XLINE = [ 17, 15, 14, 14, 17, 17, 0 ];
let FONT48_RIGHTCUT = [ 10, 32, 20, 6, 20, 0, 0 ];
let FONT48_SPACING = 4;
let FONT48_HEIGHT = 58;
let FONT48_HEIGHT_GAP = 0;
let FONT48_KERNING_GAP = 10;

//	32ポイント
let FONT32_X = [
	0, 12, 28, 52, 74, 100, 126, 138, 154, 168, 192, 218, 230, 254, 266, 298, 320, 332, 356, 376, 400, 422, 444, 464, 486,
	0, 12, 24, 48, 74, 98, 118, 144, 172, 196, 220, 246, 268, 290, 318, 342, 354, 374, 398, 420, 446, 470,
	0, 24, 48, 74, 96, 122, 146, 172, 200, 224, 250, 274, 288, 312, 326, 344, 376, 394, 414, 434, 454, 474,
	0, 18, 38, 58, 70, 88, 110, 122, 146, 164, 186, 206, 224, 244, 262, 280, 302, 324, 348, 372, 392, 414, 428, 438, 452,
	0
];
let FONT32_RIGHTCUT = [ 4, 18, 16, 26, 0 ];
let FONT32_XLINE = [ 25, 22, 22, 25, 0 ];
let FONT32_SPACING = 3;
let FONT32_HEIGHT = 40;
let FONT32_HEIGHT_GAP = 348;
let FONT32_KERNING_GAP = 5;

//	24ポイント
let FONT24_X = [
	0, 12, 26, 46, 66, 86, 108, 120, 134, 148, 168, 188, 200, 222,
	0, 26, 44, 56, 76, 94, 114, 132, 152, 170, 188, 206, 218, 230,
	0, 20, 42, 60, 82, 104, 124, 144, 166, 186, 206, 228,
	0, 12, 28, 50, 68, 90, 110, 132, 152, 172, 194, 214,
	0, 20, 42, 66, 86, 108, 128, 140, 162, 174, 190, 216, 232,
	0, 18, 34, 52, 71, 86, 104, 122, 134, 148, 168, 178, 198, 216, 234,
	0, 16, 32, 50, 66, 84, 102, 124, 144, 162, 180, 192, 204, 216,
	0
];
let FONT24_RIGHTCUT = [ 22, 6, 8, 22, 6, 4, 14, 0 ];
let FONT24_XLINE = [ 14, 14, 12, 12, 13, 15, 14, 0 ];
let FONT24_SPACING = 3;
let FONT24_HEIGHT = 32;
let FONT24_HEIGHT_GAP = 0;
let FONT24_KERNING_GAP = 6;


//	16ポイント
let FONT16_X = [
	0, 10, 20, 34, 48, 64, 78, 88, 98, 108, 122, 138, 146, 160, 170, 188, 202, 210, 224, 236,
	0, 14, 26, 40, 54, 66, 76, 84, 100, 114, 128, 142, 156, 172, 188, 202, 218, 232,
	0, 16, 32, 40, 52, 66, 80, 96, 110, 126, 140, 154, 170, 184, 198, 214, 228,
	0, 16, 30, 46, 56, 70, 80, 90, 110, 120, 134, 146, 158, 170, 184, 196, 208, 220, 230,
	0, 14, 22, 36, 50, 62, 76, 88, 100, 112, 122, 136, 150, 164, 178, 192, 204, 214, 222, 232,
	0
];
let FONT16_RIGHTCUT = [ 4, 10, 10, 14, 4, 0 ];
let FONT16_XLINE = [ 20, 18, 17, 19, 20, 0 ];
let FONT16_SPACING = 3;
let FONT16_HEIGHT = 24;
let FONT16_HEIGHT_GAP = 228;
let FONT16_KERNING_GAP = 5;

//	12ポイント
let FONT12_X = [
	0, 10, 22, 34, 48, 62, 78, 86, 98, 108, 122, 136, 146, 160, 170, 188, 202, 210, 224, 236,
	0, 14, 26, 40, 52, 66, 74, 84, 98, 114, 128, 140, 154, 170, 184, 198, 212, 226,
	0, 14, 30, 38, 50, 64, 78, 94, 106, 122, 136, 150, 164, 178, 192, 206, 220,
	0, 14, 28, 42, 54, 68, 78, 88, 106, 118, 130, 144, 156, 168, 182, 194, 206, 218, 228,
	0, 12, 22, 36, 50, 62, 74, 86, 98, 112, 122, 136, 150, 162, 176, 190, 202, 214, 222, 232,
	0
];
let FONT12_RIGHTCUT = [ 4, 16, 20, 16, 6, 0 ];
let FONT12_XLINE = [ 20, 18, 17, 19, 20, 0 ];
let FONT12_SPACING = 3;
let FONT12_HEIGHT = 20;
let FONT12_HEIGHT_GAP = 348;
let FONT12_KERNING_GAP = 6;


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	メンバ変数
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

let m_bFontInitialize = false;
let m_aszSjis16FontImage = [];
let m_szAsciiBigFontImage = "";
let m_szAsciiSmallFontImage = "";
let m_aTextCacheBeUsed = [];		//	テキストキャッシュ(使用中？)
let m_aTextCacheFile = [];			//	テキストキャッシュ(画像)
let m_aTextCacheSrcX = [];			//	テキストキャッシュ(X)
let m_aTextCacheSrcY = [];			//	テキストキャッシュ(Y)
let m_aTextCacheWidth = [];			//	テキストキャッシュ(文字幅)
let m_aTextCacheHeight = [];		//	テキストキャッシュ(文字高さ)
let m_aTextCacheKerningGap = [];	//	テキストキャッシュ(カーニング誤差)

let m_aTexTextCacheObjVisible = [];
let m_aTexTextCacheObj = [];
let m_aTexTextCacheObjWidth = [];


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	初期設定
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

function FontInitialize( let szAsciiSmallFontImage, let szAsciiBigFontImage, let aszSjis16FontImage ){
	ClearTexTextHandle();
	m_aszSjis16FontImage = m_aszSjis16FontImage[ 0..0 ] ~ aszSjis16FontImage;
	m_szAsciiBigFontImage = szAsciiBigFontImage;
	m_szAsciiSmallFontImage = szAsciiSmallFontImage;
	m_bFontInitialize = true;
}


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	キャッシュ関連
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	指定文字列をプリレンダリングし、キャッシュハンドルを返す
//	※滅多なことがない限り後述のラッパー関数を使ってください
function _CreateTexTextCache( let szTexFontFile, let nTexWidth, let aXTable, let aLineTable, let aRightCutTable, let nSpacing, let nHeight, let nHeightGap, let nKerningGap, let szText ){
	if( !m_bFontInitialize ){ return -1; }
	let anSrcX = [];
	let anSrcY = [];
	let anWidth = [];
	ascent( let i in 0..length( szText ) ){
		let code = szText[ i ] - 33;
		if( code < 0 ){	//	スペース
			anSrcX = anSrcX ~ [ -1 ];
			anSrcY = anSrcY ~ [ -1 ];
			anWidth = anWidth ~ [ nSpacing ];
		}
		else{	//	スペース以外
			let ycode = 0;
			let l = 0;
			while( ycode <= code ){
				ycode += aLineTable[ l ];
				l++;
			}
			anSrcX = anSrcX ~ [ aXTable[ code ] ];
			anSrcY = anSrcY ~ [ ( l - 1 ) * nHeight + nHeightGap ];
			anWidth = anWidth ~ [ [ aXTable[ code + 1 ], nTexWidth - aRightCutTable[ l - 1 ] ][ aXTable[ code + 1 ] == 0 ] - aXTable[ code ] ];
		}
	}
	return AddTexHandle( szTexFontFile, anSrcX, anSrcY, anWidth, nHeight, nKerningGap );
}

//	指定文字列を16ポイントフォントでプリレンダリングし、キャッシュハンドルを返す
//	※2バイト文字専用。半角との混同不可。シフトJISコード、第1・2水準に対応
function CreateTexTextSjis16Cache( let szText ){
	if( !m_bFontInitialize ){ return -1; }
	let anSrcX = [];
	let anSrcY = [];
	let anWidth = [];
	ascent( let i in 0..( length( szText ) / 2 ) ){
		let pos = Max( szText[ i * 2 ] * 256 + szText[ i * 2 + 1 ], 0 );
		ascent( let j in 0..length( FONT_SJIS_GAPPOS ) ){ if( pos > FONT_SJIS_GAPPOS[ j ] ){ pos -= FONT_SJIS_GAPLEN[ j ]; } }
		if( pos < 0 ){ pos = 0; }
		anSrcX = anSrcX ~ [ pos % 51 * 20 ];
		anSrcY = anSrcY ~ [ trunc( pos / 51 ) * 20 ];
		anWidth = anWidth ~ [ 20 ];
	}
	return AddTexHandle( FONT_SIGN_SJIS, anSrcX, anSrcY, anWidth, 20, 4 );
}

//	プリレンダリング結果をキャッシュに格納し、キャッシュハンドルを返す
//	※この関数を直接呼び出すことはまずありません(内部から自動的に使われます)
function AddTexHandle( let szTexFontFile, let anSrcX, let anSrcY, let anWidth, let nHeight, let nKerningGap ){
	ascent( let i in 0..length( m_aTextCacheBeUsed ) ){
		if( !m_aTextCacheBeUsed[ i ] ){
			m_aTextCacheBeUsed[ i ] = true;
			m_aTextCacheFile[ i ] = szTexFontFile;
			m_aTextCacheSrcX[ i ] = anSrcX;
			m_aTextCacheSrcY[ i ] = anSrcY;
			m_aTextCacheWidth[ i ] = anWidth;
			m_aTextCacheHeight[ i ] = nHeight;
			m_aTextCacheKerningGap[ i ] = nKerningGap;
			return i;
		}
	}
	m_aTextCacheBeUsed = m_aTextCacheBeUsed ~ [ true ];
	m_aTextCacheFile = m_aTextCacheFile ~ [ szTexFontFile ];
	m_aTextCacheSrcX = m_aTextCacheSrcX ~ [ anSrcX ];
	m_aTextCacheSrcY = m_aTextCacheSrcY ~ [ anSrcY ];
	m_aTextCacheWidth = m_aTextCacheWidth ~ [ anWidth ];
	m_aTextCacheHeight = m_aTextCacheHeight ~ [ nHeight ];
	m_aTextCacheKerningGap = m_aTextCacheKerningGap ~ [ nKerningGap ];
	return length( m_aTextCacheFile ) - 1;
}

//	キャッシュハンドルが有効かどうかを返す
function IsValidCacheHandle( let nHandle ){
	let nLen = length( m_aTextCacheFile );
	return ( nLen > 0 && m_bFontInitialize && nHandle >= 0 && nHandle < nLen && m_aTextCacheBeUsed[ nHandle ] );
}

//	特定キャッシュを削除する
function DeleteTexTextHandle( let nHandle ){
	if( !IsValidCacheHandle( nHandle ) ){ return; }
	m_aTextCacheBeUsed[ nHandle ] = false;
	m_aTextCacheFile[ nHandle ] = [];
	m_aTextCacheSrcX[ nHandle ] = [];
	m_aTextCacheSrcY[ nHandle ] = [];
	m_aTextCacheWidth[ nHandle ] = [];
	m_aTextCacheHeight[ nHandle ] = 0;
	m_aTextCacheKerningGap[ nHandle ] = 0;
}

//	全てのキャッシュを削除する
function ClearTexTextHandle(){
	m_aTextCacheBeUsed = m_aTextCacheBeUsed[ 0..0 ];
	m_aTextCacheFile = m_aTextCacheFile[ 0..0 ];
	m_aTextCacheSrcX = m_aTextCacheSrcX[ 0..0 ];
	m_aTextCacheSrcY = m_aTextCacheSrcY[ 0..0 ];
	m_aTextCacheWidth = m_aTextCacheWidth[ 0..0 ];
	m_aTextCacheHeight = m_aTextCacheHeight[ 0..0 ];
	m_aTextCacheKerningGap = m_aTextCacheKerningGap[ 0..0 ];
}

/*	↓↓↓以下全て_CreateTexTextCache()のラッパー関数↓↓↓	*/

//	指定文字列を12ポイントフォントでプリレンダリングし、キャッシュハンドルを返す
function CreateTexText12Cache( let szText ){
	return _CreateTexTextCache( m_szAsciiSmallFontImage, FONTSMALL_TEX_WIDTH, FONT12_X, FONT12_XLINE, FONT12_RIGHTCUT, FONT12_SPACING, FONT12_HEIGHT, FONT12_HEIGHT_GAP, FONT12_KERNING_GAP, szText );
}

//	指定文字列を16ポイントフォントでプリレンダリングし、キャッシュハンドルを返す
function CreateTexText16Cache( let szText ){
	return _CreateTexTextCache( m_szAsciiSmallFontImage, FONTSMALL_TEX_WIDTH, FONT16_X, FONT16_XLINE, FONT16_RIGHTCUT, FONT16_SPACING, FONT16_HEIGHT, FONT16_HEIGHT_GAP, FONT16_KERNING_GAP, szText );
}

//	指定文字列を24ポイントフォントでプリレンダリングし、キャッシュハンドルを返す
function CreateTexText24Cache( let szText ){
	return _CreateTexTextCache( m_szAsciiSmallFontImage, FONTSMALL_TEX_WIDTH, FONT24_X, FONT24_XLINE, FONT24_RIGHTCUT, FONT24_SPACING, FONT24_HEIGHT, FONT24_HEIGHT_GAP, FONT24_KERNING_GAP, szText );
}

//	指定文字列を32ポイントフォントでプリレンダリングし、キャッシュハンドルを返す
function CreateTexText32Cache( let szText ){
	return _CreateTexTextCache( m_szAsciiBigFontImage, FONT_TEX_WIDTH, FONT32_X, FONT32_XLINE, FONT32_RIGHTCUT, FONT32_SPACING, FONT32_HEIGHT, FONT32_HEIGHT_GAP, FONT32_KERNING_GAP, szText );
}

//	指定文字列を48ポイントフォントでプリレンダリングし、キャッシュハンドルを返す
function CreateTexText48Cache( let szText ){
	return _CreateTexTextCache( m_szAsciiBigFontImage, FONT_TEX_WIDTH, FONT48_X, FONT48_XLINE, FONT48_RIGHTCUT, FONT48_SPACING, FONT48_HEIGHT, FONT48_HEIGHT_GAP, FONT48_KERNING_GAP, szText );
}


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	絵画関連
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	テキストをキャッシュハンドルを使って絵画する
function DrawTexTextOnCache( let nHandle, let nKerning, let x, let y ){
	DrawTexTextOnCacheEx(
		nHandle, nKerning, x, y,
		0, 0, 0, 0, 0, 0, 0, 0,
		255, 255, 0, 255,
		1, 1, 0, 255, 1, 1, 0, 255,
		0, 0, -360, 360, 0, 0, -360, 360, 0, 0, -360, 360,
		255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255
	);
}

//	テキストをキャッシュハンドルを使って絵画する
//	拡張エフェクト機能つき
function DrawTexTextOnCacheEx(
	let nHandle,		let nKerning,		let x,				let y,
	let nXGapStart,		let nXGapEnd,		let nXGapLimit1,	let nXGapLimit2,
	let nYGapStart,		let nYGapEnd,		let nYGapLimit1,	let nYGapLimit2,
	let nAlphaStart,	let nAlphaEnd,		let nAlphaLimit1,	let nAlphaLimit2,
	let fScaleXStart,	let fScaleXEnd,		let fScaleXLimit1,	let fScaleXLimit2,
	let fScaleYStart,	let fScaleYEnd,		let fScaleYLimit1,	let fScaleYLimit2,
	let nRotateXStart,	let nRotateXEnd,	let nRotateXLimit1,	let nRotateXLimit2,
	let nRotateYStart,	let nRotateYEnd,	let nRotateYLimit1,	let nRotateYLimit2,
	let nRotateZStart,	let nRotateZEnd,	let nRotateZLimit1,	let nRotateZLimit2,
	let nColorRStart,	let nColorREnd,		let nColorRLimit1,	let nColorRLimit2,
	let nColorGStart,	let nColorGEnd,		let nColorGLimit1,	let nColorGLimit2,
	let nColorBStart,	let nColorBEnd,		let nColorBLimit1,	let nColorBLimit2
){
	if( !IsValidCacheHandle( nHandle ) ){ return; }
	let bNoAlpha = ( nAlphaStart == 255 && nAlphaEnd == 255 );
	let bNoScale = ( fScaleXStart == 1 && fScaleXEnd == 1 && fScaleYStart == 1 && fScaleYEnd == 1 );
	let bNoRotate = ( nRotateXStart == 0 && nRotateXEnd == 0 && nRotateYStart == 0 && nRotateYEnd == 0 && nRotateZStart == 0 && nRotateZEnd == 0 );
	let bNoColor = ( nColorRStart == 255 && nColorREnd == 255 && nColorGStart == 255 && nColorGEnd == 255 && nColorBStart == 255 && nColorBEnd == 255 );
	let anSrcX = m_aTextCacheSrcX[ nHandle ];
	let anSrcY = m_aTextCacheSrcY[ nHandle ];
	let anWidth = m_aTextCacheWidth[ nHandle ];
	let nHeight = m_aTextCacheHeight[ nHandle ];
	let nKerningGap = m_aTextCacheKerningGap[ nHandle ];
	let nLen  = length( anWidth );
	let nPosX = x;
	let bSjis = ( m_aTextCacheFile[ nHandle ] == FONT_SIGN_SJIS );
	if( !bSjis ){ SetTexture( m_aTextCacheFile[ nHandle ] ); }
	ascent( let i in 0..nLen ){
		if( bSjis ){ SetTexture( m_aszSjis16FontImage[ Min( trunc( anSrcY[ i ] / 1020 ), length( m_aszSjis16FontImage ) - 1 ) ] ); }
		let nGap;
		if( anSrcX[ i ] < 0 ){
			nGap = anWidth[ i ];
			if( i > 0 ){ nGap += anWidth[ i - 1 ] / 2; }
		}
		else{
			if( bSjis ){
				let sy = anSrcY[ i ] % 1020;
				SetGraphicRect( anSrcX[ i ], sy, anSrcX[ i ] + anWidth[ i ], sy + nHeight );
			}
			else{ SetGraphicRect( anSrcX[ i ], anSrcY[ i ] + 1, anSrcX[ i ] + anWidth[ i ], anSrcY[ i ] + nHeight - 1 ); }
			if( !bNoAlpha ){ SetAlpha( MinMax( Smooth( nAlphaStart, nAlphaEnd, i, nLen - 1 ), nAlphaLimit1, nAlphaLimit2 ) ); }
			if( !bNoScale ){
				let fScaleX;
				let fScaleY;
				if( fScaleXStart == fScaleXEnd ){ fScaleX = fScaleXStart; } else{ fScaleX = Smooth( fScaleXStart, fScaleXEnd, i, nLen - 1 ); }
				if( fScaleYStart == fScaleYEnd ){ fScaleY = fScaleYStart; } else{ fScaleY = Smooth( fScaleYStart, fScaleYEnd, i, nLen - 1 ); }
				SetGraphicScale( MinMax( fScaleX, fScaleXLimit1, fScaleXLimit2 ), MinMax( fScaleY, fScaleYLimit1, fScaleYLimit2 ) );
			}
			if( !bNoRotate ){
				let nRotateX;
				let nRotateY;
				let nRotateZ;
				if( nRotateXStart == nRotateXEnd ){ nRotateX = nRotateXStart; } else{ nRotateX = Smooth( nRotateXStart, nRotateXEnd, i, nLen - 1 ); }
				if( nRotateYStart == nRotateYEnd ){ nRotateY = nRotateYStart; } else{ nRotateY = Smooth( nRotateYStart, nRotateYEnd, i, nLen - 1 ); }
				if( nRotateZStart == nRotateZEnd ){ nRotateZ = nRotateZStart; } else{ nRotateZ = Smooth( nRotateZStart, nRotateZEnd, i, nLen - 1 ); }
				SetGraphicAngle( MinMax( nRotateX, nRotateXLimit1, nRotateXLimit2 ), MinMax( nRotateY, nRotateYLimit1, nRotateYLimit2 ), MinMax( nRotateZ, nRotateZLimit1, nRotateZLimit2 ) );
			}
			if( !bNoColor ){
				let nColorR;
				let nColorG;
				let nColorB;
				if( nColorRStart == nColorREnd ){ nColorR = nColorRStart; } else{ nColorR = Smooth( nColorRStart, nColorREnd, i, nLen - 1 ); }
				if( nColorGStart == nColorGEnd ){ nColorG = nColorGStart; } else{ nColorG = Smooth( nColorGStart, nColorGEnd, i, nLen - 1 ); }
				if( nColorBStart == nColorBEnd ){ nColorB = nColorBStart; } else{ nColorB = Smooth( nColorBStart, nColorBEnd, i, nLen - 1 ); }
				SetColor( MinMax( nColorR, nColorRLimit1, nColorRLimit2 ), MinMax( nColorG, nColorGLimit1, nColorGLimit2 ), MinMax( nColorB, nColorBLimit1, nColorBLimit2 ) );
			}
			DrawGraphic( nPosX + MinMax( Smooth( nXGapStart, nXGapEnd, i, nLen - 1 ), nXGapLimit1, nXGapLimit2 ), y + MinMax( Smooth( nYGapStart, nYGapEnd, i, nLen - 1 ), nYGapLimit1, nYGapLimit2 ) );
			nGap = anWidth[ i ] / 2;
		}
		if( ( i + 1 ) < nLen ){ nGap += anWidth[ i + 1 ] / 2; }
		nPosX += Max( 0, nGap - nKerningGap + nKerning );
		if( !bNoAlpha ){ SetAlpha( 255 ); }
		if( !bNoScale ){ SetGraphicScale( 1, 1 ); }
		if( !bNoRotate ){ SetGraphicAngle( 0, 0, 0 ); }
		if( !bNoColor ){ SetColor( 255, 255, 255 ); }
	}
}

//	テキストをキャッシュを使わず直接指定文字列を絵画する
//	※滅多なことがない限り後述のラッパー関数を使ってください
//	※注)キャッシュを使わず毎回レンダリングするので結構重いです。
function _DrawTexText(
	let szTexFontFile, let nTexWidth, let aXTable, let aLineTable, let aRightCutTable, let nHeight, let nHeightGap, let nKerningGap, let szText, let nKerning, let nSpacing, let x, let y
){
	if( !m_bFontInitialize ){ return; }
	let nHandle = _CreateTexTextCache( szTexFontFile, nTexWidth, aXTable, aLineTable, aRightCutTable, nSpacing, nHeight, nHeightGap, nKerningGap, szText );
	DrawTexTextOnCache( nHandle, nKerning, x, y );
	DeleteTexTextHandle( nHandle );
}

//	半角との混同不可
function DrawTexTextSJIS16( let szText, let nKerning, let x, let y ){
	if( !m_bFontInitialize ){ return; }
	let nHandle = CreateTexTextSjis16Cache( szText );
	DrawTexTextOnCache( nHandle, nKerning, x, y );
	DeleteTexTextHandle( nHandle );
}

/*	↓↓↓以下全て_DrawTexText()のラッパー関数↓↓↓	*/
//	※注)キャッシュを使わず毎回レンダリングするので結構重いです。

//	テキストをキャッシュを使わず指定文字列を12ポイントフォントで絵画する
function DrawTex12Text( let szText, let nKerning, let x, let y ){ _DrawTexText( m_szAsciiSmallFontImage, FONTSMALL_TEX_WIDTH, FONT12_X, FONT12_XLINE, FONT12_RIGHTCUT, FONT12_HEIGHT, FONT12_HEIGHT_GAP, FONT12_KERNING_GAP, szText, nKerning, FONT12_SPACING, x, y ); }

//	テキストをキャッシュを使わず指定文字列を16ポイントフォントで絵画する
function DrawTex16Text( let szText, let nKerning, let x, let y ){ _DrawTexText( m_szAsciiSmallFontImage, FONTSMALL_TEX_WIDTH, FONT16_X, FONT16_XLINE, FONT16_RIGHTCUT, FONT16_HEIGHT, FONT16_HEIGHT_GAP, FONT16_KERNING_GAP, szText, nKerning, FONT16_SPACING, x, y ); }

//	テキストをキャッシュを使わず指定文字列を24ポイントフォントで絵画する
function DrawTex24Text( let szText, let nKerning, let x, let y ){ _DrawTexText( m_szAsciiSmallFontImage, FONTSMALL_TEX_WIDTH, FONT24_X, FONT24_XLINE, FONT24_RIGHTCUT, FONT24_HEIGHT, FONT24_HEIGHT_GAP, FONT24_KERNING_GAP, szText, nKerning, FONT24_SPACING, x, y ); }

//	テキストをキャッシュを使わず指定文字列を32ポイントフォントで絵画する
function DrawTex32Text( let szText, let nKerning, let x, let y ){ _DrawTexText( m_szAsciiSmallFontImage, FONT_TEX_WIDTH, FONT32_X, FONT32_XLINE, FONT32_RIGHTCUT, FONT32_HEIGHT, FONT32_HEIGHT_GAP, FONT32_KERNING_GAP, szText, nKerning, FONT32_SPACING, x, y ); }

//	テキストをキャッシュを使わず指定文字列を48ポイントフォントで絵画する
function DrawTex48Text( let szText, let nKerning, let x, let y ){ _DrawTexText( m_szAsciiBigFontImage, FONT_TEX_WIDTH, FONT48_X, FONT48_XLINE, FONT48_RIGHTCUT, FONT48_HEIGHT, FONT48_HEIGHT_GAP, FONT48_KERNING_GAP, szText, nKerning, FONT48_SPACING, x, y ); }


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	キャッシュ関連(obj)
//	旧版と比べるとかなり重いので(DrawText()より若干マシ程度)
//	ステージ中は旧版を使ってください
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	キャッシュを生成する
function _CreateTexTextCacheObj( let szTexFontFile, let nTexWidth, let aXTable, let aLineTable, let aRightCutTable, let nSpacing, let nHeight, let nHeightGap, let nKerningGap, let szText ){
	if( !m_bFontInitialize ){ return -1; }
	let anObj = [];
	let anWidth = [];
	ascent( let i in 0..length( szText ) ){
		let obj = -1;
		let code = szText[ i ] - 33;
		let nWidth = nSpacing * 2;
		if( code >= 0 ){	//	スペース以外
			let ycode = 0;
			let l = 0;
			while( ycode <= code ){
				ycode += aLineTable[ l ];
				l++;
			}
			obj = Obj_Create( OBJ_EFFECT );
			Obj_SetAutoDelete( obj, false );
			Obj_SetPosition( obj, -128, -128 );
			ObjEffect_SetTexture( obj, szTexFontFile );
			ObjEffect_SetRenderState( obj, ALPHA );
			ObjEffect_SetPrimitiveType( obj, PRIMITIVE_TRIANGLESTRIP );
			ObjEffect_CreateVertex( obj, 4 );
			nWidth = [ aXTable[ code + 1 ], nTexWidth - aRightCutTable[ l - 1 ] ][ aXTable[ code + 1 ] == 0 ] - aXTable[ code ];
			let nSrcY = ( l - 1 ) * nHeight + nHeightGap;
			ascent( let j in 0..4 ){
				let nColor = [ 255, 192 ][ j % 2 ];
				ObjEffect_SetVertexXY( obj, j, nWidth / 2 * [ -1, 1 ][ trunc( j / 2 ) ], nHeight / 2 * [ -1, 1 ][ j % 2 ] );
				ObjEffect_SetVertexUV( obj, j ,aXTable[ code ] + [ 0, nWidth ][ trunc( j / 2 ) ], nSrcY + [ 0, nHeight ][ j % 2 ] );
				ObjEffect_SetVertexColor( obj, j, 255, nColor, nColor, nColor );
			}
		}
		anObj = anObj ~ [ obj ];
		anWidth = anWidth ~ [ nWidth - [ nKerningGap, 0 ][ obj < 0 ] ];
	}
	return AddTexHandleObj( anObj, anWidth );
}

//	キャッシュを配列に格納し、ハンドルを返す
function AddTexHandleObj( let anObj, let anWidth ){
	ascent( let i in 0..length( m_aTexTextCacheObj ) ){
		if( !IsValidCacheHandleObj( i ) ){
			m_aTexTextCacheObj[ i ] = anObj;
			m_aTexTextCacheObjWidth[ i ] = anWidth;
			m_aTexTextCacheObjVisible[ i ] = false;
			return i;
		}
	}
	m_aTexTextCacheObj = m_aTexTextCacheObj ~ [ anObj ];
	m_aTexTextCacheObjWidth = m_aTexTextCacheObjWidth ~ [ anWidth ];
	m_aTexTextCacheObjVisible = m_aTexTextCacheObjVisible ~ [ false ];
	return length( m_aTexTextCacheObj ) - 1;
}

//	ハンドルが有効かどうかチェック
function IsValidCacheHandleObj( let nHandle ){
	let nLen = length( m_aTexTextCacheObj );
	return ( nLen > 0 && m_bFontInitialize && nHandle >= 0 && nHandle < nLen && length( m_aTexTextCacheObj[ nHandle ] ) > 0 );
}

//	ハンドルを削除する
function DeleteTexTextHandleObj( let nHandle ){
	if( !IsValidCacheHandleObj( nHandle ) ){ return; }
	let anObj = m_aTexTextCacheObj[ nHandle ];
	ascent( let i in 0..length( anObj ) ){ Obj_Delete( anObj[ i ] ); }
	m_aTexTextCacheObj[ nHandle ] = [];
	m_aTexTextCacheObjWidth[ nHandle ] = [];
	m_aTexTextCacheObjVisible[ nHandle ] = false;
}

//	キャッシュをクリアする
function ClearTexTextHandleObj(){ ascent( let i in 0..length( m_aTexTextCacheObj ) ){ DeleteTexTextHandleObj( i ); } }

//	簡易エフェクトをリセットする
function ResetTexTextEffect( let nHandle ){
	if( !IsValidCacheHandleObj( nHandle ) ){ return; }
	let anObj = m_aTexTextCacheObj[ nHandle ];
	ascent( let i in 0..length( anObj ) ){
		if( anObj[ i ] >= 0 ){
			ObjEffect_SetScale( anObj[ i ], 1, 1 );
			ObjEffect_SetAngle( anObj[ i ], 0, 0, 0 );
			ascent( let j in 0..4 ){ ObjEffect_SetVertexColor( anObj[ i ], j, 255, 255, 255, 255 ); }
		}
	}
}

//	文字を不可視にする
function HiddenTexTextObj( let nHandle, let bReset ){
	if( !IsValidCacheHandleObj( nHandle ) ){ return; }
	if( bReset ){ ResetTexTextEffect( nHandle ); }
	m_aTexTextCacheObjVisible[ nHandle ] = false;
	let anObj = m_aTexTextCacheObj[ nHandle ];
	ascent( let i in 0..length( anObj ) ){
		ObjEffect_SetLayer( anObj[ i ], 0 );
		Obj_SetPosition( anObj[ i ], -128, -128 );
	}
}

//	表示中？
function IsVisibleTexText( let nHandle ){
	if( !IsValidCacheHandleObj( nHandle ) ){ return false; }
	return m_aTexTextCacheObjVisible[ nHandle ];
}

//	文字を表示する
function ViewTexTextObj( let nHandle, let nKerning, let nX, let nY, let nLayer ){
	ViewTexTextObjEx(
		nHandle, nKerning, nX, nY, nLayer,
		0, 0, 0, 0, 0, 0, 0, 0,
		255, 255, 0, 255,
		1, 1, 0, 255, 1, 1, 0, 255,
		0, 0, -360, 360, 0, 0, -360, 360, 0, 0, -360, 360,
		255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255
	);
}

//	簡易エフェクト対応文字表示(49引数)
function ViewTexTextObjEx(
	let nHandle, let nKerning, let nX, let nY, let nLayer,
	let nXGapStart,		let nXGapEnd,		let nXGapLimit1,	let nXGapLimit2,
	let nYGapStart,		let nYGapEnd,		let nYGapLimit1,	let nYGapLimit2,
	let nAlphaStart,	let nAlphaEnd,		let nAlphaLimit1,	let nAlphaLimit2,
	let fScaleXStart,	let fScaleXEnd,		let fScaleXLimit1,	let fScaleXLimit2,
	let fScaleYStart,	let fScaleYEnd,		let fScaleYLimit1,	let fScaleYLimit2,
	let nRotateXStart,	let nRotateXEnd,	let nRotateXLimit1,	let nRotateXLimit2,
	let nRotateYStart,	let nRotateYEnd,	let nRotateYLimit1,	let nRotateYLimit2,
	let nRotateZStart,	let nRotateZEnd,	let nRotateZLimit1,	let nRotateZLimit2,
	let nColorRStart,	let nColorREnd,		let nColorRLimit1,	let nColorRLimit2,
	let nColorGStart,	let nColorGEnd,		let nColorGLimit1,	let nColorGLimit2,
	let nColorBStart,	let nColorBEnd,		let nColorBLimit1,	let nColorBLimit2
){
	if( !IsValidCacheHandleObj( nHandle ) ){ return; }
	m_aTexTextCacheObjVisible[ nHandle ] = true;
	let bNoGapX = ( nXGapStart == 0 && nXGapEnd == 0 && nXGapLimit1 == 0 && nXGapLimit2 == 0 );
	let bNoGapY = ( nYGapStart == 0 && nYGapEnd == 0 && nYGapLimit1 == 0 && nYGapLimit2 == 0 );
	let bNoAlpha = ( nAlphaStart == 255 && nAlphaEnd == 255 );
	let bNoScale = ( fScaleXStart == 1 && fScaleXEnd == 1 && fScaleYStart == 1 && fScaleYEnd == 1 );
	let bNoRotate = ( nRotateXStart == 0 && nRotateXEnd == 0 && nRotateYStart == 0 && nRotateYEnd == 0 && nRotateZStart == 0 && nRotateZEnd == 0 );
	let bNoColor = ( nColorRStart == 255 && nColorREnd == 255 && nColorGStart == 255 && nColorGEnd == 255 && nColorBStart == 255 && nColorBEnd == 255 );
	let anObj = m_aTexTextCacheObj[ nHandle ];
	let anWidth = m_aTexTextCacheObjWidth[ nHandle ];
	let nDstX = nX;
	let nLen = length( anObj );
	ascent( let i in 0..nLen ){
		if( anObj[ i ] >= 0 ){
			let nXGap = 0;
			let nYGap = 0;
			if( !bNoGapX ){ if( nXGapStart == nXGapEnd ){ nXGap = nXGapStart; } else{ nXGap = Smooth( nXGapStart, nXGapEnd, i, nLen - 1 ); } }
			if( !bNoGapY ){ if( nYGapStart == nYGapEnd ){ nYGap = nYGapStart; } else{ nYGap = Smooth( nYGapStart, nYGapEnd, i, nLen - 1 ); } }
			if( !bNoScale ){
				let fScaleX;
				let fScaleY;
				if( fScaleXStart == fScaleXEnd ){ fScaleX = fScaleXStart; } else{ fScaleX = Smooth( fScaleXStart, fScaleXEnd, i, nLen - 1 ); }
				if( fScaleYStart == fScaleYEnd ){ fScaleY = fScaleYStart; } else{ fScaleY = Smooth( fScaleYStart, fScaleYEnd, i, nLen - 1 ); }
				ObjEffect_SetScale( anObj[ i ], MinMax( fScaleX, fScaleXLimit1, fScaleXLimit2 ), MinMax( fScaleY, fScaleYLimit1, fScaleYLimit2 ) );
			}
			if( !bNoRotate ){
				let nRotateX;
				let nRotateY;
				let nRotateZ;
				if( nRotateXStart == nRotateXEnd ){ nRotateX = nRotateXStart; } else{ nRotateX = Smooth( nRotateXStart, nRotateXEnd, i, nLen - 1 ); }
				if( nRotateYStart == nRotateYEnd ){ nRotateY = nRotateYStart; } else{ nRotateY = Smooth( nRotateYStart, nRotateYEnd, i, nLen - 1 ); }
				if( nRotateZStart == nRotateZEnd ){ nRotateZ = nRotateZStart; } else{ nRotateZ = Smooth( nRotateZStart, nRotateZEnd, i, nLen - 1 ); }
				ObjEffect_SetAngle( anObj[ i ], MinMax( nRotateX, nRotateXLimit1, nRotateXLimit2 ), MinMax( nRotateY, nRotateYLimit1, nRotateYLimit2 ), MinMax( nRotateZ, nRotateZLimit1, nRotateZLimit2 ) );
			}
			if( !( bNoAlpha && bNoColor ) ){
				let nAlpha = 255;
				let nColor = [ 255, 255, 255 ];
				if( !bNoAlpha ){ nAlpha = MinMax( Smooth( nAlphaStart, nAlphaEnd, i, nLen - 1 ), nAlphaLimit1, nAlphaLimit2 ); }
				if( !bNoColor ){
					if( nColorRStart == nColorREnd ){ nColor[ 0 ] = nColorRStart; } else{ nColor[ 0 ] = Smooth( nColorRStart, nColorREnd, i, nLen - 1 ); }
					if( nColorGStart == nColorGEnd ){ nColor[ 1 ] = nColorGStart; } else{ nColor[ 1 ] = Smooth( nColorGStart, nColorGEnd, i, nLen - 1 ); }
					if( nColorBStart == nColorBEnd ){ nColor[ 2 ] = nColorBStart; } else{ nColor[ 2 ] = Smooth( nColorBStart, nColorBEnd, i, nLen - 1 ); }
				}
				ascent( let j in 0..3 ){ nColor[ j ] = MinMax( nColor[ j ], [ nColorRLimit1, nColorBLimit1, nColorGLimit1 ][ j ], [ nColorRLimit2, nColorBLimit2, nColorGLimit2 ][ j ] ); }
				ascent( let j in 0..4 ){ ObjEffect_SetVertexColor( anObj[ i ], j, nAlpha, nColor[ 0 ] * [ 1, 0.75 ][ j % 2 ], nColor[ 1 ] * [ 1, 0.75 ][ j % 2 ], nColor[ 2 ] * [ 1, 0.75 ][ j % 2 ] ); }
			}
			Obj_SetPosition( anObj[ i ], nDstX + MinMax( nXGap, nXGapLimit1, nXGapLimit2 ), nY + MinMax( nYGap, nYGapLimit1, nYGapLimit2 ) );
			ObjEffect_SetLayer( anObj[ i ], nLayer );
		}
		nDstX += anWidth[ i ] / 2 + anWidth[ Min( i + 1, nLen - 1 ) ] / 2 + nKerning;
	}
}

/*	↓↓↓以下全て_CreateTexTextCacheObj()のラッパー関数↓↓↓	*/

//	指定文字列を12ポイントフォントでプリレンダリングし、キャッシュハンドルを返す
function CreateTexText12CacheObj( let szText ){
	return _CreateTexTextCacheObj( m_szAsciiSmallFontImage, FONTSMALL_TEX_WIDTH, FONT12_X, FONT12_XLINE, FONT12_RIGHTCUT, FONT12_SPACING, FONT12_HEIGHT, FONT12_HEIGHT_GAP, FONT12_KERNING_GAP, szText );
}

//	指定文字列を16ポイントフォントでプリレンダリングし、キャッシュハンドルを返す
function CreateTexText16CacheObj( let szText ){
	return _CreateTexTextCacheObj( m_szAsciiSmallFontImage, FONTSMALL_TEX_WIDTH, FONT16_X, FONT16_XLINE, FONT16_RIGHTCUT, FONT16_SPACING, FONT16_HEIGHT, FONT16_HEIGHT_GAP, FONT16_KERNING_GAP, szText );
}

//	指定文字列を24ポイントフォントでプリレンダリングし、キャッシュハンドルを返す
function CreateTexText24CacheObj( let szText ){
	return _CreateTexTextCacheObj( m_szAsciiSmallFontImage, FONTSMALL_TEX_WIDTH, FONT24_X, FONT24_XLINE, FONT24_RIGHTCUT, FONT24_SPACING, FONT24_HEIGHT, FONT24_HEIGHT_GAP, FONT24_KERNING_GAP, szText );
}

//	指定文字列を32ポイントフォントでプリレンダリングし、キャッシュハンドルを返す
function CreateTexText32CacheObj( let szText ){
	return _CreateTexTextCacheObj( m_szAsciiBigFontImage, FONT_TEX_WIDTH, FONT32_X, FONT32_XLINE, FONT32_RIGHTCUT, FONT32_SPACING, FONT32_HEIGHT, FONT32_HEIGHT_GAP, FONT32_KERNING_GAP, szText );
}

//	指定文字列を48ポイントフォントでプリレンダリングし、キャッシュハンドルを返す
function CreateTexText48CacheObj( let szText ){
	return _CreateTexTextCacheObj( m_szAsciiBigFontImage, FONT_TEX_WIDTH, FONT48_X, FONT48_XLINE, FONT48_RIGHTCUT, FONT48_SPACING, FONT48_HEIGHT, FONT48_HEIGHT_GAP, FONT48_KERNING_GAP, szText );
}
