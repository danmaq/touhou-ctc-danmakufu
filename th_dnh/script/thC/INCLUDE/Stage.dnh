//////////////////////////////////////////////////////////////////////
//====================================================================
//
//	ステージスクリプト部専用上位ライブラリ
//
//		※ステージスクリプト以外ではインクルードしないでください。
//
//====================================================================
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	下位ライブラリをインクルード
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

#include_function ".\INCLUDE\Common.dnh"
#include_function ".\INCLUDE\withoutEvent.dnh"
#include_function ".\INCLUDE\CutIn.dnh"


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	インデックスをインクルード
//	※夢終劇以外に流用する場合は必要に応じて削除してください
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

#include_function "\img\index.dnh"
#include_function "\se\index.dnh"
#include_function ".\IMAGE\index.dnh"
#include_function ".\SOUND\index.dnh"
#include_function ".\_index.dnh"
#include_function ".\STAGE\index.dnh"	// これを一番最後に読まんとステージからインデックスが使えない


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	定数
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

let ITEM_DEFAULT_TABLE = [		//	アイテム出現テーブル(後で本家を参照して完全な形にする)
//	ITEMEX_POWER_BIG, ITEMEX_POWER_BIG, ITEMEX_POWER_BIG, ITEMEX_POWER_BIG, ITEMEX_POWER_BIG, ITEMEX_POWER_BIG, ITEMEX_POWER_BIG, ITEMEX_POWER_BIG, ITEMEX_POWER_BIG, ITEMEX_POWER_BIG, ITEMEX_POWER_BIG, ITEMEX_POWER_BIG, 
	ITEMEX_POWER, ITEMEX_POWER, ITEMEX_SCORE, ITEMEX_POWER, ITEMEX_POWER, ITEMEX_POWER, ITEMEX_SCORE, ITEMEX_POWER, ITEMEX_POWER, ITEMEX_SCORE, ITEMEX_POWER, ITEMEX_POWER, ITEMEX_POWER, ITEMEX_SCORE, ITEMEX_POWER,
	ITEMEX_SCORE, ITEMEX_POWER, ITEMEX_POWER, ITEMEX_SCORE, ITEMEX_POWER, ITEMEX_POWER, ITEMEX_POWER, ITEMEX_POWER, ITEMEX_SCORE, ITEMEX_POWER_BIG, ITEMEX_POWER, ITEMEX_POWER, ITEMEX_POWER, ITEMEX_SCORE, ITEMEX_POWER,
	ITEMEX_POWER, ITEMEX_SCORE, ITEMEX_POWER, ITEMEX_SCORE, ITEMEX_POWER, ITEMEX_POWER, ITEMEX_POWER, ITEMEX_POWER, ITEMEX_SCORE, ITEMEX_POWER, ITEMEX_POWER, ITEMEX_SCORE, ITEMEX_POWER, ITEMEX_SCORE, ITEMEX_POWER,
];

let PROGRESS_BOTTOMMARGIN = 64;	//	ローダープログレスバーの画面下端からの距離
let PROGRESS_PHASE = 32767;		//	ローダー作動中のフェイズ番号

let KEY_REPEAT_CYCLE = 6;		//	キーリピートが発動した時のリピートサイクル
let KEY_REPEAT_TIME = 20;		//	キーリピートが発動するまでの待ちフレーム

let MENU_FADE = 60;				//	メニューのフェード時間


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	メンバ変数
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

let m_nPlayerDefaultX = -1;			//	プレイヤー初期X座標
let m_nPlayerDefaultY = -1;			//	プレイヤー初期X座標

let m_nLoadProgressPercentage = -1;	//	ローダーの進捗率

let m_nStage = -1;					//	現在のステージ
let m_nStageCount = 0;				//	ステージの開始された時間
let m_nStageLevel = 1;				//	ステージランク

let m_nKeyHold = -1;				//	押したキーの種類
let m_nKeyHoldTime = 0;				//	最後にキーを押した時間

let m_nMenuCursorMoveTime = 0;		//	最後にメニューカーソルを動かした時間
let m_nMenuPrevCursor = -1;			//	前のカーソル位置
let m_bMenuBack = false;			//	メニューバックしたか

let m_nItemPointSmall = 0;			//	小点
let m_nItemPowerPrev = -1;			//	前フレームのPower値
let m_nItemHakureiPrev = -1;		//	前フレームの博麗小符数
let m_nItemDefaultIndex = 0;		//	デフォルトアイテム出現テーブルのインデックス

let m_hTTCacheStageLevel = -1;		//	レベル表示のキャッシュ
let m_hTTCachePower = -1;			//	Power値表示のキャッシュ
let m_hTTCacheHakurei = -1;			//	博麗小符表示のキャッシュ
let m_aItemGetPoint = [];			//	アイテム取ったどー


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	キー入力判定
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	キーリピート対応版GetKeyState()
//	リピート発動するとその度にKEY_PUSHを返す
function GetKeyStateEx( let nType ){
	let nResult = GetKeyState( nType );
	alternative( nResult )
	case( KEY_PUSH ){
		if( m_nKeyHold != nType ){
			m_nKeyHold = nType;
			m_nKeyHoldTime = m_nCount;
		}
	}
	case( KEY_HOLD ){
		if( m_nKeyHold == nType ){
			let nRepeatStartCount = m_nCount - ( m_nKeyHoldTime + KEY_REPEAT_TIME );
			if( nRepeatStartCount >= 0 ){
				alternative( nRepeatStartCount % KEY_REPEAT_CYCLE )
				case( 0 ){ return KEY_PULL; }
				case( 1 ){ return KEY_PUSH; }
			}
		}
	}
	case( KEY_FREE, KEY_PULL ){
		if( m_nKeyHold == nType ){
			m_nKeyHold = -1;
			m_nKeyHoldTime = 0;
		}
	}
	return nResult;
}

//	方向キーを押したか否かを返す
function IsPushDirKey(){ return GetKeyState( VK_UP ) == KEY_PUSH || GetKeyState( VK_DOWN ) == KEY_PUSH || GetKeyState( VK_LEFT ) == KEY_PUSH || GetKeyState( VK_RIGHT ) == KEY_PUSH; }

//	方向キーを押したか否かを返す(キーリピート対応版
function IsPushDirKeyEx(){ return GetKeyStateEx( VK_UP ) == KEY_PUSH || GetKeyStateEx( VK_DOWN ) == KEY_PUSH || GetKeyStateEx( VK_LEFT ) == KEY_PUSH || GetKeyStateEx( VK_RIGHT ) == KEY_PUSH; }


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	メニュー機能
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	メニューカーソル移動
function MenuSelect( let nNowSelect, let szSESelect, let nMenuNum, let anLock ){
	let res = nNowSelect;
	if( IsPushDirKeyEx() ){
		m_nMenuPrevCursor = nNowSelect;
		PlaySE( szSESelect );
		let bLock = true;
		while( bLock ){
			if( nMenuNum > 10 ){
				if( GetKeyStateEx( VK_UP ) == KEY_PUSH ){ res--; }
				if( GetKeyStateEx( VK_DOWN ) == KEY_PUSH ){ res++; }
				if( GetKeyStateEx( VK_LEFT ) == KEY_PUSH ){ res -= 10; }
				if( GetKeyStateEx( VK_RIGHT ) == KEY_PUSH ){ res += 10; }
			}
			else{ res += [ 1, -1 ][ GetKeyStateEx( VK_UP ) == KEY_PUSH || GetKeyStateEx( VK_LEFT ) == KEY_PUSH ]; }
			res = MinMaxLoop( res, 0, nMenuNum );
			bLock = false;
			if( length( anLock ) == 0 ){ bLock = false; }
			ascent( let i in 0..length( anLock ) ){
				bLock = [ bLock, true ][ res == anLock[ i ] ];
			}
		}
		m_nMenuCursorMoveTime = m_nCount;
	}
	return res;
}

//	決定・キャンセル判定
function IsMenuEnter( let szSEEnter, let szSECancel ){
	m_nMenuPrevCursor = -1;
	m_nMenuCursorMoveTime = 0;
	if( GetKeyStateEx( VK_BOMB ) == KEY_PUSH ){
		PlaySE( szSECancel );
		m_bMenuBack = true;
		return false;
	}
	else{
		PlaySE( szSEEnter );
		m_bMenuBack = false;
		return true;
	}
}


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	ステージ制御
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	指定ステージに設定する
function SetStage( let nStage ){
	ClearPhase();
	m_nStage = nStage;
	m_nStageCount = m_nCount;
}

//	次のステージへ行く
function SetNextStage(){ SetStage( m_nStage + 1 ); }

//	ステージ送り（デバッグ用）
function SkipStage(){if(GetKeyState(VK_SKIP)==KEY_PUSH){SetNextStage();}}


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	プレイヤー初期位置関連
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	プレイヤー初期位置を保存
//	※必ず@MainLoop()の最初のフレームで実行してください
function SetPlayerDefaultPosition(){
	if( m_nPlayerDefaultX >= 0 || m_nPlayerDefaultY >= 0 ){ return; }
	m_nPlayerDefaultX = GetPlayerX();
	m_nPlayerDefaultY = GetPlayerY();
}

//	プレイヤー初期位置に強制移動させる
function MovePlayerDefaultPosition(){
	SetPlayerX( m_nPlayerDefaultX );
	SetPlayerY( m_nPlayerDefaultY );
}


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	アイテム関係関数
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	キューにたまったアイテムを吸い出し画面内に吐き出す
function PopItemQueue(){
	let aItem = GetCommonDataDefault( CD_ITEM_QUEUE_CREATE, [] );
	ascent( let i in 0..length( aItem ) ){
		let aItemInfo = aItem[ i ];
		let nPower = GetCommonDataDefault( CD_ITEM_POWER, 0 );
		if( aItemInfo[ 0 ] == ITEMEX_DEFAULT ){
			aItemInfo[ 0 ] = ITEM_DEFAULT_TABLE[ m_nItemDefaultIndex ];
			m_nItemDefaultIndex = ( m_nItemDefaultIndex + 1 ) % length( ITEM_DEFAULT_TABLE );
		}
		if( nPower == 128 ){
			alternative( aItemInfo[ 0 ] )
			case( ITEMEX_POWER ){ aItemInfo[ 0 ] = ITEMEX_SCORE_SMALL; }
			case( ITEMEX_POWER_BIG, ITEMEX_POWER_FULL ){ aItemInfo[ 0 ] = ITEMEX_SCORE; }
		}
		ObjItem( aItemInfo[ 0 ], aItemInfo[ 1 ], aItemInfo[ 2 ], aItemInfo[ 3 ], aItemInfo[ 4 ] )
	}
	SetCommonData( CD_ITEM_QUEUE_CREATE, [] );
	descent( let i in 0..length( m_aItemGetPoint ) ){
		let aItemGetPointInfo = m_aItemGetPoint[ i ];
		aItemGetPointInfo[ 3 ] = aItemGetPointInfo[ 3 ] - 1;
		m_aItemGetPoint[ i ] = aItemGetPointInfo;
		if( m_nCount - aItemGetPointInfo[ 0 ] > 50 ){ m_aItemGetPoint = erase( m_aItemGetPoint, i ); }
	}
}

//	画面外アイテムマーカー
task ItemMarker( let nItemObj, let nKind ){
	let obj = Obj_Create( OBJ_EFFECT );
	ObjEffect_SetLayer( obj, 4 );
	ObjEffect_SetTexture( obj, imgMapWhite );
	ObjEffect_SetRenderState( obj, ALPHA );
	ObjEffect_SetPrimitiveType( obj, PRIMITIVE_TRIANGLESTRIP );
	ObjEffect_CreateVertex( obj, 3 );
	ascent( let i in 0..3 ){
		ObjEffect_SetVertexXY( obj, i, [ 0, -6, 6 ][ i ], [ -4, 2, 2 ][ i ] );
		ObjEffect_SetVertexColor( obj, i, 255,
			[ 0,	32,		68,	128,	223,	223,	191,	0,		191	][ nKind ],
			[ 0,	0,		68,	128,	0,		0,		191,	223,	0	][ nKind ],
			[ 224,	159,	68,	128,	0,		0,		0,		0,		191	][ nKind ]
		);
	}
	while( !Obj_BeDeleted( obj ) ){
		if( Obj_BeDeleted( nItemObj ) || Obj_GetY( nItemObj ) > GetClipMinY() ){ Obj_Delete( obj ); }
		else{ Obj_SetPosition( obj, Obj_GetX( nItemObj ), GetClipMinY() + 12 ); }
		yield;
	}
}

//	アイテムオブジェクトタスク
task ObjItem( let nKind, let nX, let nY, let nFirstSpeed, let nAngle ){
	let nObjCount = 0;
	let nScale = [ 6, 8 ][ nKind >= ITEMEX_POWER_BIG ];
	let obj = Obj_Create( OBJ_EFFECT );
	let bHoming = false;
	Obj_SetAngle( obj, nAngle );
	Obj_SetAutoDelete( obj, false );
	ObjEffect_SetLayer( obj, 4 );
	ObjEffect_SetTexture( obj, imgDnhItem );
	ObjEffect_SetRenderState( obj, ALPHA );
	ObjEffect_SetPrimitiveType( obj, PRIMITIVE_TRIANGLESTRIP );
	ObjEffect_CreateVertex( obj, 4 );
	Obj_SetPosition( obj, GetCenterX(), GetCenterY() );
	ascent( let i in 0..4 ){
		ObjEffect_SetVertexXY( obj, i, [ -1, -1, 1, 1 ][ i ] * nScale, [ -1, 1, -1, 1 ][ i ] * nScale );
		ObjEffect_SetVertexColor( obj, i, 255, 255, 255, 255 );
		ObjEffect_SetVertexUV( obj, i,
			[
				[ 2,	40,	21,	2,	59,	57,	38,	19,	0 ][ nKind ],
				[ 14,	52,	33,	14,	71,	73,	54,	35,	16 ][ nKind ],
			][ trunc( i / 2 ) ],
			[
				[ 21,	21,	21,	40,	21,	0,	0,	0,	0 ][ nKind ],
				[ 33,	33,	33,	52,	33,	16,	16,	16,	16 ][ nKind ],
			][ i % 2 ],
		);
	}
	Obj_SetPosition( obj, nX, nY );
	while( !Obj_BeDeleted( obj ) ){
		let nX = Obj_GetX( obj );
		let nY = Obj_GetY( obj );
		if( nY < GetClipMinY() ){ ItemMarker( obj, nKind ); }
		let nPower = GetCommonDataDefault( CD_ITEM_POWER, 0 );
		if( nPower == 128 ){
			if( !GetCommonDataDefault( CD_PLAYER_ONMISSED, false ) && GetPlayerY() < 128 ){ bHoming = true; }
			alternative( nKind )
			case( ITEMEX_POWER ){
				ObjItem( ITEMEX_SCORE_SMALL, nX, nY, 1, 270 );
				Obj_Delete( obj );
			}
			case( ITEMEX_POWER_BIG, ITEMEX_POWER_FULL ){
				ObjItem( ITEMEX_SCORE, nX, nY, 1, 270 );
				Obj_Delete( obj );
			}
		}
		let nSpeed = SlowDown( nFirstSpeed, -2.5, nObjCount, 120 );
		if( nSpeed < 0 ){
			Obj_SetAngle( obj, 270 );
			alternative( nKind )
			case( ITEMEX_SCORE_STAR, ITEMEX_HAKUREI ){ bHoming = true; }
		}
		if( OnBomb() ){ bHoming = true; }
		if( nObjCount > 10 && bHoming ){
			Obj_SetSpeed( obj, 10 );
			Obj_SetAngle( obj, GetGapAngle( nX, nY, GetPlayerX(), GetPlayerY() ) );
		}
		else{ Obj_SetSpeed( obj, nSpeed ); }
		if( ( !GetCommonDataDefault( CD_PLAYER_ONMISSED, false ) || bHoming ) && Hypot( GetPlayerX() - nX, GetPlayerY() - nY ) < 22 ){
			ItemGet( nKind, nX, nY );
			Obj_Delete( obj );
		}
		if( nY > GetClipMaxY() + 32 ){ Obj_Delete( obj ); }
		yield;
		nObjCount++;
	}
}

//	アイテム取ったどー！！１！
function ItemGet( let nKind, let nX, let nY ){
	let nScore = 10;
	let bStrong = false;
	PlaySE( seScore );
	alternative( nKind )
	case( ITEMEX_SCORE ){
		AddPoint( 1 );
		nScore = SlowDown( 100000, 10000, nY - 128, GetClipMaxY() - 128 );
		bStrong = nScore == 100000;
	}
	case( ITEMEX_SCORE_SMALL ){
		m_nItemPointSmall++;
		if( m_nItemPointSmall > 10 ){
			m_nItemPointSmall = 0;
			AddPoint( 1 );
		}
		nScore = SlowDown( 10000, 1000, nY - 128, GetClipMaxY() - 128 );
		bStrong = nScore == 10000;
	}
	case( ITEMEX_SCORE_STAR ){ nScore = 100; }
	case( ITEMEX_POWER, ITEMEX_POWER_BIG, ITEMEX_POWER_FULL ){
		let nPower = GetCommonDataDefault( CD_ITEM_POWER, 0 );
		alternative( nKind )
		case( ITEMEX_POWER ){ nPower++; }
		case( ITEMEX_POWER_BIG ){ nPower += 8; }
		case( ITEMEX_POWER_FULL ){ nPower += 128; }
		SetCommonData( CD_ITEM_POWER, Min( nPower, 128 ) );
	}
	case( ITEMEX_BOMB ){ AddBomb( 1 ); }
	case( ITEMEX_EXTEND ){ ExtendPlayer( 1 ); }
	case( ITEMEX_HAKUREI ){ SetCommonData( CD_ITEM_HAKUREI, GetCommonDataDefault( CD_ITEM_HAKUREI, 0 ) + 1 ); }
	AddScore( nScore );
	let aItemGetPointInfo = [ m_nCount, CreateTexText16Cache( ToStringInt( nScore ) ), nX, nY, [ 0, 1 ][ bStrong ] ];
	m_aItemGetPoint = m_aItemGetPoint ~ [ aItemGetPointInfo ];
}

//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	リザルト関係関数
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

let m_anStageResultFontCache = [ -1, -1, -1, -1, -1, -1, -1 ];
let m_anStageResultCaptionFontCache = [ -1, -1, -1, -1, -1, -1, -1 ];
let m_anStageResultTitileFontCache = [ -1, -1 ];

function InitializeResult(){
	ascent( let i in 0..length( m_anStageResultTitileFontCache ) ){ m_anStageResultTitileFontCache[ i ] = CreateTexText32Cache( [ "STAGE CLEAR!", "ALL CLEAR!" ][ i ] ); }
	ascent( let i in 0..length( m_anStageResultCaptionFontCache ) ){ m_anStageResultCaptionFontCache[ i ] = CreateTexText24Cache( [ "STAGE", "POINT", "GRAZE", "RATE", "PLAYER", "BOMB", "TOTAL" ][ i ] ); }
}

function PopResult(){
	if( m_nLoadProgressPercentage != -1 && m_anStageResultFontCache[ 0 ] != -1 ){
		ascent( let i in 0..length( m_anStageResultFontCache ) ){
			DeleteTexTextHandle( m_anStageResultFontCache[ i ] );
			m_anStageResultFontCache[ i ] = -1;
		}
	}
	if( !GetCommonDataDefault( CD_RESULT, false ) ){ return; }
	ascent( let i in 0..length( m_anStageResultFontCache ) ){
		if( i != 4 && i != 5 ){ m_anStageResultFontCache[ i ] = CreateTexText24Cache(
			ToStringInt( GetCommonDataDefault( [ CD_RESULT_CLEAR, CD_RESULT_POINT, CD_RESULT_GRAZE, CD_RESULT_RATE, "dummy", "dummy", CD_RESULT_TOTAL ][ i ], 0 ) ) ~ [ "", "%" ][ i == 3 ]
		); }
	}
	DeleteCommonData( CD_RESULT );
	DeleteCommonData( CD_RESULT_CLEAR );
	DeleteCommonData( CD_RESULT_POINT );
	DeleteCommonData( CD_RESULT_GRAZE );
	DeleteCommonData( CD_RESULT_RATE );
	DeleteCommonData( CD_RESULT_TOTAL );
}

function DrawStageResult(){
	let bResult = false;
	ascent( let i in 0..length( m_anStageResultFontCache ) ){
		if( m_anStageResultFontCache[ i ] != -1 ){
			if( i >= 4 ){ SetColor( 255, 255, 128 ); }
			if( i == 3 || i == 6 ){ SetColor( 255, 128, 128 ); }
			bResult = true;
			DrawTexTextOnCache( m_anStageResultCaptionFontCache[ i ], 0, 128, i * 24 + 96 );
			DrawTexTextOnCache( m_anStageResultFontCache[ i ], 0, 256, i * 24 + 96 );
		}
	}
	if( bResult ){ DrawTexTextOnCache( m_anStageResultTitileFontCache[ 0 ], 0, GetCenterX() - 96, 64 ); }
	SetColor( 255, 255, 255 );
}


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	マイクロスレッド制御
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	キー入力をnWaitフレームだけ待つ
function WaitPushKey( let Key, let nWait ){
	let nCount = 0;
	while( nCount < nWait && GetKeyState( Key ) != KEY_PUSH ){
		yield;
		nCount++;
	}
}


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	ロード/セーブ関連
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	ローダー本体
function LoadProgress( let aszGraphicFileList, let aszEnemyFileList, let aszSEFileList, let szTexProgressFile, let szTexFillFile ){
	let nGraphicListElems = length( aszGraphicFileList );
	let nSEListElems = length( aszSEFileList );
	let nTotalElems = nGraphicListElems + nSEListElems + length( aszEnemyFileList );
	SetDefaultStatusVisible( false );
	GosubPhase( PROGRESS_PHASE );
	ViewLoadProgress( szTexProgressFile, szTexFillFile );
	ascent( let i in 0..nTotalElems ){
		m_nLoadProgressPercentage = Smooth( 0, 100, i, nTotalElems );
		if( i < nGraphicListElems ){ LoadGraphic( aszGraphicFileList[ i ] ); }
		else if( i - nGraphicListElems < nSEListElems ){ LoadSE( aszSEFileList[ i - nGraphicListElems ] ); }
		else{ CompileEnemyFromFile( aszEnemyFileList[ i - nGraphicListElems - nSEListElems ] ); }
		yield;
	}
	ReturnPhase();
	m_nLoadProgressPercentage = -1;
	SetDefaultStatusVisible( true );
}

task ViewLoadProgress( let szTexProgressFile, let szTexFillFile ){
	let objFill = Obj_Create( OBJ_EFFECT );
	Obj_SetAutoDelete( objFill, false );
	ObjEffect_SetTexture( objFill, szTexFillFile );
	ObjEffect_SetRenderState( objFill, ALPHA );
	ObjEffect_SetPrimitiveType( objFill, PRIMITIVE_TRIANGLESTRIP );
	ObjEffect_SetLayer( objFill, 8 );
	ObjEffect_CreateVertex( objFill, 4 );
	ascent( let i in 0..4 ){
		ObjEffect_SetVertexXY( objFill, i, [ 0, 640 ][ trunc( i / 2 ) ], [ 0, 480 ][ i % 2 ] );
		ObjEffect_SetVertexColor( objFill, i, 255, 0, 0, 0 );
	}
	Obj_SetPosition( objFill, 0, 0 );

	let objProgressBG = Obj_Create( OBJ_EFFECT );
	Obj_SetAutoDelete( objProgressBG, false );
	ObjEffect_SetTexture( objProgressBG, szTexProgressFile );
	ObjEffect_SetRenderState( objProgressBG, ALPHA );
	ObjEffect_SetPrimitiveType( objProgressBG, PRIMITIVE_TRIANGLESTRIP );
	ObjEffect_SetLayer( objProgressBG, 8 );
	ObjEffect_CreateVertex( objProgressBG, 4 );
	ascent( let i in 0..4 ){
		ObjEffect_SetVertexXY( objProgressBG, i, [ 0, 640 ][ trunc( i / 2 ) ], [ -16, 0 ][ i % 2 ] );
		ObjEffect_SetVertexUV( objProgressBG, i, [ 0, 256 ][ trunc( i / 2 ) ], [ 16, 32 ][ i % 2 ] );
		ObjEffect_SetVertexColor( objProgressBG, i, 128, 255, 255, 255 );
	}
	Obj_SetPosition( objProgressBG, 0, 480 );

	let objProgress = Obj_Create( OBJ_EFFECT );
	Obj_SetAutoDelete( objProgress, false );
	ObjEffect_SetTexture( objProgress, szTexProgressFile );
	ObjEffect_SetRenderState( objProgress, ALPHA );
	ObjEffect_SetPrimitiveType( objProgress, PRIMITIVE_TRIANGLESTRIP );
	ObjEffect_SetLayer( objProgress, 8 );
	ObjEffect_CreateVertex( objProgress, 4 );
	ascent( let i in 0..4 ){
		ObjEffect_SetVertexXY( objProgress, i, [ 0, 0 ][ trunc( i / 2 ) ], [ -16, 0 ][ i % 2 ] );
		ObjEffect_SetVertexUV( objProgress, i, [ 0, 256 ][ trunc( i / 2 ) ], [ 0, 16 ][ i % 2 ] );
		ObjEffect_SetVertexColor( objProgress, i, 255, 255, 255, 255 );
	}
	Obj_SetPosition( objProgress, 0, 480 );

	while( GetPhase() == PROGRESS_PHASE ){
		ascent( let i in 0..4 ){ ObjEffect_SetVertexXY( objProgress, i, [ 0, Smooth( 0, 640, m_nLoadProgressPercentage, 100 ) ][ trunc( i / 2 ) ], [ -16, 0 ][ i % 2 ] ); }
		yield;
	}
	Obj_Delete( objFill );
	Obj_Delete( objProgress );
	Obj_Delete( objProgressBG );
}


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	BGM/SE関連
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	30フレームのミュート時間を設けてBGMを再生する
task PlayMusicEx( let nBGMIndex, let szName ){
	StopMusic();
	_PlayMusicEx( bgmList[ nBGMIndex ], szName );
}

//	BGMを停止する(無音BGMを再生する)
function StopMusic(){
	ascent( let i in 1..length( bgmList ) ){ DeleteMusic( bgmList[ i ] ); }
	PlayMusic( bgmList[ 0 ] );
}


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	絵画関連
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	指定テクスチャで塗りつぶす
function DrawScreenFill( let szTexFillFile ){
	SetGraphicRect( 0, 0, 512, 512 );
	DrawCenter( szTexFillFile );
}

//	ローダーの進捗状況を絵画する
function DrawLoadProgress( let szTexProgressFile, let szTexFillFile ){
	let nPercentage = m_nLoadProgressPercentage;
	if( nPercentage == -1 ){ return; }
	DrawScreenFill( szTexFillFile );
	_DrawChrRect( szTexProgressFile, GetCenterX(), GetClipMaxY() - PROGRESS_BOTTOMMARGIN, 0, 16, 256, 32 );
	SetGraphicExpansion( Smooth( 0, 1, nPercentage, 100 ), 1 );
	_DrawChrRect( szTexProgressFile, GetCenterX() - Smooth( 128, 0, nPercentage, 100 ), GetClipMaxY() - PROGRESS_BOTTOMMARGIN, 0, 0, 256, 16 );
	SetGraphicExpansion( 1, 1 );
}

//	メニューを絵画する
function ViewMenu( let nTargetPhase, let nX, let nY, let nGapX, let nGapY, let anTexTextHandle, let nSelect, let anLock ){
	let bInPhase = GetPhase() == nTargetPhase;
	if( !bInPhase && m_nPrevPhase != nTargetPhase ){
		ascent( let i in 0..length( anTexTextHandle ) ){ HiddenTexTextObj( anTexTextHandle[ i ], true ); }
		return;
	}
	let nKerning = 0;
	let nAngle = SlowDown( [ 0, -120 ][ bInPhase ], [ -60, 0 ][ bInPhase ], m_nPhaseNow, MENU_FADE );
	let nScaleX = [ Smooth( 1, 3, m_nPhaseNow, MENU_FADE ), 1 ][ bInPhase ];
	ascent( let i in 0..length( anTexTextHandle ) ){
		let bLock = false;
		ascent( let j in 0..length( anLock ) ){ bLock = [ bLock, true ][ i == anLock[ j ] ]; }
		ResetTexTextEffect( anTexTextHandle[ i ] );
		let nMoveX = 0;
		let nAlpha;
		if( bInPhase ){
			nKerning = SlowDown( -32, 0, m_nPhaseNow, MENU_FADE );
			nX = SlowDown( 0, nX, m_nPhaseNow, MENU_FADE );
			if( i != m_nMenuPrevCursor ){
				if( i == nSelect ){ nMoveX = Smooth( 0, 4, m_nPhaseNow, MENU_FADE / 10 ); }
				nAlpha = Accelerate( 0, [ 80, 255 ][ i == nSelect ], m_nPhaseNow, MENU_FADE );
			}
			else{
				nMoveX = Smooth( 4, 0, m_nPhaseNow, MENU_FADE / 10 );
				nAlpha = SlowDown( Accelerate( 0, 255, m_nPhaseNow, MENU_FADE ), 80, m_nCount - m_nMenuCursorMoveTime, MENU_FADE / 10 );
			}
		}
		else{
			nAlpha = SlowDown( [ 80, 255 ][ i == nSelect ], 0, m_nPhaseNow, MENU_FADE / [ 5, 1 ][ i == nSelect && !m_bMenuBack ] );
			if( i == nSelect ){ nMoveX = 4; }
		}
		let nColorB = 223 + 32 * [ 1, sin( m_nCount * 2 ) ][ i == nSelect ];
		if( nAlpha == 0 ){ HiddenTexTextObj( anTexTextHandle[ i ], false ); }
		else{
			ViewTexTextObjEx(
				anTexTextHandle[ i ], nKerning, nX * i + nGapX - nMoveX, nY * i + nGapY, 8,
				0, 0, 0, 0, 0, 0, 0, 0,
				nAlpha, nAlpha, 0, 255,
				nScaleX, nScaleX, 0, 3, 1, 1, 0, 255,
				0, 0, 0, 0, 0, 0, 0, 0, nAngle, nAngle, -720, 720,
				255, 255, 0, 255, [ 255, 0 ][ bLock ], [ 255, 0 ][ bLock ], 0, 255, nColorB, nColorB, 0, 255
			);
		}
	}
}

//	ステージの各情報を絵画する
function DrawStage(){
	SetAlpha( Smooth( 32, 240, GetGapLength( GetClipMaxX() - 32, GetClipMaxY() - 24, GetPlayerX(), GetPlayerY() ), 128 ) );
	DrawTexTextOnCache( m_hTTCacheStageLevel, 0, GetClipMaxX() - 56, GetClipMaxY() - 12 );
	SetColor( 255, 192, 192 );
	DrawTexTextOnCache( m_hTTCachePower, 0, GetClipMaxX() - 56, GetClipMaxY() - 24 );
	if( GetCommonDataDefault( CD_ENABLE_HAKUREI, false ) ){
		SetColor( 240, 160, 255 );
		DrawTexTextOnCache( m_hTTCacheHakurei, 0, GetClipMaxX() - 56, GetClipMaxY() - 36 );
	}
	ascent( let i in 0..length( m_aItemGetPoint ) ){
		let aItemGetPointInfo = m_aItemGetPoint[ i ];
		SetAlpha( Accelerate( 255, 32, m_nCount - aItemGetPointInfo[ 0 ], 50 ) );
		SetColor( 255, 255, [ 255, 128 ][ aItemGetPointInfo[ 4 ] == 1 ] );
		DrawTexTextOnCache( aItemGetPointInfo[ 1 ], 0, aItemGetPointInfo[ 2 ], aItemGetPointInfo[ 3 ] );
	}
	SetColor( 255, 255, 255 );
	SetAlpha( 255 );
}
