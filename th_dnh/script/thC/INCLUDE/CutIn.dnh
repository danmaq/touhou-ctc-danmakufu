//////////////////////////////////////////////////////////////////////
//====================================================================
//
//	イベントスクリプト以外の共通下位ライブラリ
//		プレイヤースクリプトとの共用のため隔離
//
//		※各上位ライブラリから間接的にインクルードされます。
//			直接インクルードすることはありません。
//		※イベントスクリプトでは使用できません。
//
//====================================================================
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	下位ライブラリをインクルード
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

#include_function "script\thC\INCLUDE\Font.dnh"
#include_function "script\thC\INCLUDE\Draw.dnh"


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	定数
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	メンバ変数
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

let m_nCutInStartCount = -1;
let m_bCutInPlayer;
let m_szCutInImage;
let m_nCutInWidth;
let m_nCutInHeight;
let m_nCutIn1X;
let m_nCutIn1Alpha;
let m_nCutIn1ScaleX;
let m_nCutIn1ScaleY;
let m_nCutIn2Y;
let m_nCutIn2Alpha;
let m_nCutIn2Scale;
let m_nSpellNameCacheHandle = -1;
let m_nSpellNameX;
let m_nSpellNameY;
let m_nSpellNameYGapStart;
let m_nSpellNameYGapEnd;
let m_nSpellNameAlphaStart;
let m_nSpellNameAlphaEnd;
let m_nSpellNameScaleXStart;
let m_nSpellNameScaleXEnd;
let m_szSpellNameBGImage;
let m_nSpellNameBGX;
let m_nSpellBonus = 0;


//////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
//	カットイン関連
//--------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////

//	今カットイン中？
function IsCutIn(){ return ( m_nCutInStartCount != -1 || m_nSpellNameCacheHandle != -1 ); }

//	カットイン終了処理
//	※敵スペルカードの@Finalize()で呼び出すこと
function EndCutIn(){
	DeleteTexTextHandle( m_nSpellNameCacheHandle );
	m_nSpellNameCacheHandle = -1;
	m_nCutInStartCount = -1;
}

//	カットインキューを拾って自動的にカットインを発動する
//	※ステージより自動的に呼び出されます、直接使用することはありません。
function PopCutInQueue( let szBackGroundImage, let szFontImage, let szFontSmallImage, let aszFontSJIS16Image ){
	if( !PopCommonData( CD_CUTIN_START, false ) ){ return; }
	m_nCutInStartCount = m_nCount;
	let szSpellName = PopCommonData( CD_CUTIN_SPELL_NAME, "ＴＥＳＴ" );
	m_bCutInPlayer = PopCommonData( CD_CUTIN_PLAYER, false );
	m_szCutInImage = PopCommonData( CD_CUTIN_IMAGE_FILE, "" );
	m_nCutInWidth = PopCommonData( CD_CUTIN_IMAGE_WIDTH, 0 );
	m_nCutInHeight = PopCommonData( CD_CUTIN_IMAGE_HEIGHT, 0 );
	m_szSpellNameBGImage = szBackGroundImage;
	_THC_CutIn( szSpellName, szFontImage, szFontSmallImage, aszFontSJIS16Image );
}

//	カットインを初期化(ステージの敵・自機スクリプトで呼んだ場合ステージスクリプトの方にキューを投げる)
function THC_CutIn( let nCount, let bPlayer, let szCutInImage, let nCutInWidth, let nCutInHeight, let szSpellName, let szBackGroundImage, let szFontImage, let szFontSmallImage, let aszFontSJIS16Image ){
	let bTHC = GetCommonDataDefault( CD_THC_STAGE, false );
	m_nCutInStartCount = nCount;
	m_szCutInImage = szCutInImage;
	m_nCutInWidth = nCutInWidth;
	m_nCutInHeight = nCutInHeight;
	m_bCutInPlayer = bPlayer;
	m_szSpellNameBGImage = szBackGroundImage;
	if( bTHC && bPlayer ){
		SetCommonData( CD_CUTIN_START, true );
		SetCommonData( CD_CUTIN_PLAYER, bPlayer );
		SetCommonData( CD_CUTIN_IMAGE_FILE, szCutInImage );
		SetCommonData( CD_CUTIN_IMAGE_WIDTH, nCutInWidth );
		SetCommonData( CD_CUTIN_IMAGE_HEIGHT, nCutInHeight );
		SetCommonData( CD_CUTIN_SPELL_NAME, szSpellName );
	}
	else{ _THC_CutIn( szSpellName, szFontImage, szFontSmallImage, aszFontSJIS16Image ); }
}

//	※THC_CutInから自動的に呼ばれる内部関数
function _THC_CutIn( let szSpellName, let szFontImage, let szFontSmallImage, let aszFontSJIS16Image ){
	if( !GetCommonDataDefault( CD_THC_STAGE, false ) || !m_bCutInPlayer ){ FontInitialize( szFontSmallImage, szFontImage, aszFontSJIS16Image ); }
	m_nSpellNameCacheHandle = CreateTexTextSjis16Cache( szSpellName );
	task_THC_Cutin();
	_SpellName();
}

//	スペルテキストタスク
task _SpellName(){
	let nObjCount = 0;
	let nEnemyY = GetCenterY() + 64;
	m_nSpellNameX = [ GetClipMinX() + 32, GetCenterX() - 32 ][ m_bCutInPlayer ];
	m_nSpellNameY = [ nEnemyY, GetClipMaxY() - 24 ][ m_bCutInPlayer ];
	let nLimit = 50;
	ascent( let i in 0..( nLimit + 1 ) ){
		m_nSpellNameBGX = SlowDown( [ GetClipMinX(), GetClipMaxX() ][ m_bCutInPlayer ], GetCenterX() + 16 * [ -1, 1 ][ m_bCutInPlayer ], i, nLimit );
		m_nSpellNameYGapStart = SlowDown( -24, 0, i, 20 );
		m_nSpellNameYGapEnd = SlowDown( -64, 0, i, nLimit );
		m_nSpellNameAlphaStart = Smooth( 0, 255, i, 20 );
		m_nSpellNameAlphaEnd = Smooth( -512, 255, i, nLimit );
		m_nSpellNameScaleXStart = Smooth( 3, -3, i, 30 );
		m_nSpellNameScaleXEnd = Smooth( 9, 1, i, nLimit );
		yield;
	}
	while( [ !GetCommonDataDefault( CD_CUTIN_SPELL_END, false ), OnBomb() ][ m_bCutInPlayer ] ){
		if( !m_bCutInPlayer ){ m_nSpellNameY = SplineFakeSFS( nEnemyY, GetClipMinY() + 48, nObjCount - 30, 30 ); }
		yield;
		nObjCount++;
	}
	SetCommonData( CD_CUTIN_SPELL_END, false );
	nLimit = 50;
	ascent( let i in 0..( nLimit + 1 ) ){
		m_nSpellNameAlphaStart = Smooth( 255, 0, i, 20 );
		m_nSpellNameAlphaEnd = Smooth( 512, 0, i, nLimit );
		yield;
	}
	DeleteTexTextHandle( m_nSpellNameCacheHandle );
	m_nSpellNameCacheHandle = -1;
}

//	カットインタスク
task task_THC_Cutin(){
	let x1 = [ GetClipMaxX(), GetClipMinX() ][ m_bCutInPlayer ] + ( m_nCutInWidth / 2 + 32 ) * [ -1, 1 ][ m_bCutInPlayer ];
	let y1 = GetClipMaxY() + m_nCutInHeight * 2;
	let a1 = 240;
	let a2 = 32;
	let nLimit = 5;
	m_nCutIn1ScaleY = 1;
	m_nCutIn2Scale = 3;
	ascent( let i in 0..( nLimit + 1 ) ){
		m_nCutIn1X = Smooth( [ GetClipMinX(), GetClipMaxX() ][ m_bCutInPlayer ], x1, i, nLimit );
		m_nCutIn1Alpha = Accelerate( 0, a1, i, nLimit );
		m_nCutIn2Alpha = Accelerate( 0, a2, i, nLimit );
		m_nCutIn1ScaleX = Accelerate( 3, 1, i, nLimit );
		m_nCutIn2Y = Smooth( y1, GetClipMaxY(), i, nLimit );
		yield;
	}
	let x2 = x1 + 32 * [ 1, -1 ][ m_bCutInPlayer ];
	let y2 = GetClipMaxY() - 96;
	nLimit = 60;
	ascent( let i in 0..( nLimit + 1 ) ){
		m_nCutIn1X = SlowDown( x1, x2, i, nLimit );
		m_nCutIn2Y = SlowDown( GetClipMaxY(), y2, i, nLimit );
		yield;
	}
	nLimit = 10;
	ascent( let i in 0..( nLimit + 1 ) ){
		m_nCutIn1Alpha = Smooth( a1, 0, i, nLimit );
		m_nCutIn2Alpha = Accelerate( a2, 0, i, nLimit );
		m_nCutIn1ScaleX = Accelerate( 1, 5, i, nLimit );
		m_nCutIn1ScaleY = SlowDown( 1, 0, i, nLimit );
		m_nCutIn2Scale = Accelerate( 3, 8, i, nLimit );
		yield;
	}
	m_nCutInStartCount = -1;
}

//	カットインを絵画
function DrawCutIn( let nCount ){
	if( m_nCutInStartCount > 0 ){
		if( m_nCutIn1Alpha > 0 ){
			SetAlpha( m_nCutIn1Alpha );
			SetGraphicScale( m_nCutIn1ScaleX, m_nCutIn1ScaleY );
			SetGraphicRect( 0, 0, m_nCutInWidth, m_nCutInHeight );
			_DrawChr( m_szCutInImage, m_nCutIn1X, GetClipMaxY() - m_nCutInHeight / 2 );
		}
		if( m_nCutIn2Alpha > 0 ){
			SetAlpha( m_nCutIn2Alpha );
			SetGraphicScale( m_nCutIn2Scale, m_nCutIn2Scale );
			_DrawChr( m_szCutInImage, GetCenterX(), m_nCutIn2Y );
		}
		SetAlpha( 255 );
		SetGraphicScale( 1, 1 );
	}
	if( m_nSpellNameCacheHandle != -1 ){
		let nNow = m_nCount - m_nCutInStartCount;
		let nSrcY = [ [ 325, 37, 73, 109, 145 ][ GetCommonDataDefault( CD_STAGE_SCENARIO, -1 ) + 1 ], 0 ][ m_bCutInPlayer ];
		SetAlpha( MinMax( [ m_nSpellNameAlphaEnd, nNow * 3 ][ nNow < 60 ], 0, 128 ) );
		_DrawChrRect( m_szSpellNameBGImage, m_nSpellNameBGX, m_nSpellNameY, 0, nSrcY, 384, nSrcY + 34 );
		SetAlpha( 255 );
		DrawTexTextOnCacheEx(
			m_nSpellNameCacheHandle, -2, m_nSpellNameX, m_nSpellNameY,
			0, 0, 0, 0,
			m_nSpellNameYGapStart, m_nSpellNameYGapEnd, -16, 0,
			m_nSpellNameAlphaStart, m_nSpellNameAlphaEnd, 0, 255,
			m_nSpellNameScaleXStart / 1.5, m_nSpellNameScaleXEnd / 1.5, 1, 3,
			m_nSpellNameScaleXStart, m_nSpellNameScaleXEnd, 1, 3,
			0, 0, 0, 0,
			0, 0, 0, 0,
			0, 0, 0, 0,
			[ 255,	192 ][ m_bCutInPlayer ], [ 255,	160 ][ m_bCutInPlayer ], 0, 255,
			[ 128,	192 ][ m_bCutInPlayer ], [ 192,	128 ][ m_bCutInPlayer ], 0, 255,
			[ 160,	255 ][ m_bCutInPlayer ], [ 192,	255 ][ m_bCutInPlayer ], 0, 255
		);
		if( !m_bCutInPlayer ){ DrawTex12Text( "SCORE : " ~ ToStringInt( m_nSpellBonus ), 2, m_nSpellNameX, m_nSpellNameY + 16 ); }
	}
}
